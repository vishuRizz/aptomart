{"version":3,"sources":["/opt/git/typescript-sdk/dist/common/index.js","../../src/bcs/consts.ts","../../src/bcs/deserializer.ts","../../src/core/hex.ts","../../src/core/common.ts","../../src/core/accountAddress.ts","../../src/core/crypto/privateKey.ts","../../src/errors/index.ts","../../src/client/get.ts","../../src/types/generated/queries.ts","../../src/internal/account.ts","../../src/api/account.ts","../../src/api/aptosConfig.ts"],"names":["MAX_U8_NUMBER","MAX_U16_NUMBER","MAX_U32_NUMBER","MAX_U64_BIG_INT","MAX_U128_BIG_INT","MAX_U256_BIG_INT","Deserializer","data","length","bytes","value","type","len","bool","low","high","shift","byte","cls","vector","ParsingError","message","invalidReason","HexInvalidReason","Hex","_Hex","bytesToHex","options"],"mappings":"AAAA,2sCAAgH,ICOnGA,EAAAA,CAAuB,GAAA,CACvBC,EAAAA,CAAyB,KAAA,CACzBC,EAAAA,CAAyB,UAAA,CACzBC,EAAAA,CAA0B,qBAAA,CAC1BC,EAAAA,CAA4B,wCAAA,CAC5BC,EAAAA,CACX,+EAAA,CCyBK,IAAMC,CAAAA,CAAN,KAAmB,CAWxB,WAAA,CAAYC,CAAAA,CAAkB,CAE5B,IAAA,CAAK,MAAA,CAAS,IAAI,WAAA,CAAYA,CAAAA,CAAK,MAAM,CAAA,CACzC,IAAI,UAAA,CAAW,IAAA,CAAK,MAAM,CAAA,CAAE,GAAA,CAAIA,CAAAA,CAAM,CAAC,CAAA,CACvC,IAAA,CAAK,MAAA,CAAS,CAChB,CAQQ,IAAA,CAAKC,CAAAA,CAA6B,CACxC,EAAA,CAAI,IAAA,CAAK,MAAA,CAASA,CAAAA,CAAS,IAAA,CAAK,MAAA,CAAO,UAAA,CACrC,MAAM,IAAI,KAAA,CAAM,8BAA8B,CAAA,CAGhD,IAAMC,CAAAA,CAAQ,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,IAAA,CAAK,MAAA,CAAQ,IAAA,CAAK,MAAA,CAASD,CAAM,CAAA,CACjE,OAAA,IAAA,CAAK,MAAA,EAAUA,CAAAA,CACRC,CACT,CASA,SAAA,CAAA,CAAoB,CAClB,OAAO,IAAA,CAAK,MAAA,CAAO,UAAA,CAAa,IAAA,CAAK,MACvC,CAgBA,cAAA,CAAA,CAAyB,CACvB,IAAMC,CAAAA,CAAQ,IAAA,CAAK,gBAAA,CAAiB,CAAA,CAEpC,OADoB,IAAI,WAAA,CAAY,CAAA,CACjB,MAAA,CAAOA,CAAK,CACjC,CA0CA,iBAAA,CACEC,CAAAA,CACAC,CAAAA,CACqC,CAErC,EAAA,CADe,IAAA,CAAK,eAAA,CAAgB,CAAA,CAGpC,CAAA,EAAA,CAAID,CAAAA,GAAS,QAAA,CACX,OAAO,IAAA,CAAK,cAAA,CAAe,CAAA,CAE7B,EAAA,CAAIA,CAAAA,GAAS,OAAA,CACX,OAAO,IAAA,CAAK,gBAAA,CAAiB,CAAA,CAE/B,EAAA,CAAIA,CAAAA,GAAS,YAAA,CAAc,CACzB,EAAA,CAAIC,CAAAA,GAAQ,KAAA,CAAA,CACV,MAAM,IAAI,KAAA,CAAM,iCAAiC,CAAA,CAEnD,OAAO,IAAA,CAAK,qBAAA,CAAsBA,CAAG,CACvC,CAEA,OAAO,IAAA,CAAK,WAAA,CAAYD,CAAI,CAAA,CAC9B,CAUA,gBAAA,CAAA,CAA+B,CAC7B,IAAMC,CAAAA,CAAM,IAAA,CAAK,uBAAA,CAAwB,CAAA,CACzC,OAAO,IAAI,UAAA,CAAW,IAAA,CAAK,IAAA,CAAKA,CAAG,CAAC,CACtC,CAOA,qBAAA,CAAsBA,CAAAA,CAAyB,CAC7C,OAAO,IAAI,UAAA,CAAW,IAAA,CAAK,IAAA,CAAKA,CAAG,CAAC,CACtC,CAWA,eAAA,CAAA,CAA2B,CACzB,IAAMC,CAAAA,CAAO,IAAI,UAAA,CAAW,IAAA,CAAK,IAAA,CAAK,CAAC,CAAC,CAAA,CAAE,CAAC,CAAA,CAC3C,EAAA,CAAIA,CAAAA,GAAS,CAAA,EAAKA,CAAAA,GAAS,CAAA,CACzB,MAAM,IAAI,KAAA,CAAM,uBAAuB,CAAA,CAEzC,OAAOA,CAAAA,GAAS,CAClB,CASA,aAAA,CAAA,CAAuB,CACrB,OAAO,IAAI,QAAA,CAAS,IAAA,CAAK,IAAA,CAAK,CAAC,CAAC,CAAA,CAAE,QAAA,CAAS,CAAC,CAC9C,CAYA,cAAA,CAAA,CAAyB,CACvB,OAAO,IAAI,QAAA,CAAS,IAAA,CAAK,IAAA,CAAK,CAAC,CAAC,CAAA,CAAE,SAAA,CAAU,CAAA,CAAG,CAAA,CAAI,CACrD,CAYA,cAAA,CAAA,CAAyB,CACvB,OAAO,IAAI,QAAA,CAAS,IAAA,CAAK,IAAA,CAAK,CAAC,CAAC,CAAA,CAAE,SAAA,CAAU,CAAA,CAAG,CAAA,CAAI,CACrD,CAYA,cAAA,CAAA,CAAyB,CACvB,IAAMC,CAAAA,CAAM,IAAA,CAAK,cAAA,CAAe,CAAA,CAC1BC,CAAAA,CAAO,IAAA,CAAK,cAAA,CAAe,CAAA,CAGjC,OAAO,MAAA,CAAQ,MAAA,CAAOA,CAAI,CAAA,EAAK,MAAA,CAAO,EAAE,CAAA,CAAK,MAAA,CAAOD,CAAG,CAAC,CAC1D,CAQA,eAAA,CAAA,CAA2B,CACzB,IAAMA,CAAAA,CAAM,IAAA,CAAK,cAAA,CAAe,CAAA,CAC1BC,CAAAA,CAAO,IAAA,CAAK,cAAA,CAAe,CAAA,CAGjC,OAAO,MAAA,CAAQA,CAAAA,EAAQ,MAAA,CAAO,EAAE,CAAA,CAAKD,CAAG,CAC1C,CASA,eAAA,CAAA,CAA2B,CACzB,IAAMA,CAAAA,CAAM,IAAA,CAAK,eAAA,CAAgB,CAAA,CAC3BC,CAAAA,CAAO,IAAA,CAAK,eAAA,CAAgB,CAAA,CAGlC,OAAO,MAAA,CAAQA,CAAAA,EAAQ,MAAA,CAAO,GAAG,CAAA,CAAKD,CAAG,CAC3C,CAUA,uBAAA,CAAA,CAAkC,CAChC,IAAIJ,CAAAA,CAAgB,MAAA,CAAO,CAAC,CAAA,CACxBM,CAAAA,CAAQ,CAAA,CAEZ,GAAA,CAAA,CAAON,CAAAA,CAAQR,EAAAA,CAAAA,CAAgB,CAC7B,IAAMe,CAAAA,CAAO,IAAA,CAAK,aAAA,CAAc,CAAA,CAGhC,EAAA,CAFAP,CAAAA,EAAS,MAAA,CAAOO,CAAAA,CAAO,GAAI,CAAA,EAAK,MAAA,CAAOD,CAAK,CAAA,CAEvC,CAAA,CAAAC,CAAAA,CAAO,GAAA,CAAA,CACV,KAAA,CAEFD,CAAAA,EAAS,CACX,CAEA,EAAA,CAAIN,CAAAA,CAAQR,EAAAA,CACV,MAAM,IAAI,KAAA,CAAM,qDAAqD,CAAA,CAGvE,OAAO,MAAA,CAAOQ,CAAK,CACrB,CAeA,WAAA,CAAeQ,CAAAA,CAA2B,CAGxC,OAAOA,CAAAA,CAAI,WAAA,CAAY,IAAI,CAC7B,CAwBA,iBAAA,CAAqBA,CAAAA,CAAkC,CACrD,IAAMV,CAAAA,CAAS,IAAA,CAAK,uBAAA,CAAwB,CAAA,CACtCW,CAAAA,CAAS,IAAI,KAAA,CACnB,GAAA,CAAA,IAAS,CAAA,CAAI,CAAA,CAAG,CAAA,CAAIX,CAAAA,CAAQ,CAAA,EAAK,CAAA,CAC/BW,CAAAA,CAAO,IAAA,CAAK,IAAA,CAAK,WAAA,CAAYD,CAAG,CAAC,CAAA,CAEnC,OAAOC,CACT,CACF,CAAA,CC9WA,4CAAuC,ICG1BC,CAAAA,CAAN,MAAA,QAA8B,KAAM,CAczC,WAAA,CAAYC,CAAAA,CAAiBC,CAAAA,CAAkB,CAC7C,KAAA,CAAMD,CAAO,CAAA,CACb,IAAA,CAAK,aAAA,CAAgBC,CACvB,CACF,CAAA,CDdO,IAAKC,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CACVA,CAAAA,CAAA,SAAA,CAAY,WAAA,CACZA,CAAAA,CAAA,cAAA,CAAiB,gBAAA,CACjBA,CAAAA,CAAA,iBAAA,CAAoB,mBAAA,CAHVA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAA,CAAA,CAAA,CAAA,CA8BCC,CAAAA,eAAN,MAAMC,CAAI,CAQf,WAAA,CAAYlB,CAAAA,CAAkB,CAC5B,IAAA,CAAK,IAAA,CAAOA,CACd,CAWA,YAAA,CAAA,CAA2B,CACzB,OAAO,IAAA,CAAK,IACd,CAOA,qBAAA,CAAA,CAAgC,CAC9B,OAAOmB,+BAAAA,IAAW,CAAK,IAAI,CAC7B,CAOA,QAAA,CAAA,CAAmB,CACjB,MAAO,CAAA,EAAA,EAAK,IAAA,CAAK,qBAAA,CAAsB,CAAC,CAAA,CAAA;AE+RsB;ACpStD,SAAA;AC0LI,SAAA;AAGA,SAAA;AAEA,eAAA;AAEF,OAAA;AC7IkD,2BAAA;AC3HhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBL,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaW,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgDlB,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWD,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkCiB,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmCf,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYW,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYG,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYd,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaM,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOV,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+Bc,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBF,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcpB,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBiB,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0BF,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBhB,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYa,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQR,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBK,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASD,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBI,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcL,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYQ,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYZ,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AClRPC,IAAAA;AC6gBb;ACjeN,0CAAA","file":"/opt/git/typescript-sdk/dist/common/index.js","sourcesContent":[null,"// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Uint8, Uint16, Uint32, Uint64, Uint128, Uint256 } from \"../types\";\n\n// Upper bound values for uint8, uint16, uint64 etc.  These are all derived as\n// 2^N - 1, where N is the number of bits in the type.\nexport const MAX_U8_NUMBER: Uint8 = 255;\nexport const MAX_U16_NUMBER: Uint16 = 65535;\nexport const MAX_U32_NUMBER: Uint32 = 4294967295;\nexport const MAX_U64_BIG_INT: Uint64 = 18446744073709551615n;\nexport const MAX_U128_BIG_INT: Uint128 = 340282366920938463463374607431768211455n;\nexport const MAX_U256_BIG_INT: Uint256 =\n  115792089237316195423570985008687907853269984665640564039457584007913129639935n;\n","// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-bitwise */\nimport { MAX_U32_NUMBER } from \"./consts\";\nimport { Uint8, Uint16, Uint32, Uint64, Uint128, Uint256 } from \"../types\";\n\n/**\n * This interface exists to define Deserializable<T> inputs for functions that\n * deserialize a byte buffer into a type T.\n * It is not intended to be implemented or extended, because Typescript has no support\n * for static methods in interfaces.\n *\n * @template T - The type that this will deserialize into.\n */\nexport interface Deserializable<T> {\n  /**\n   * Deserializes the buffered bytes into an instance of the specified class type.\n   * This function provides an alternative syntax for deserialization, allowing users to call\n   * `deserializer.deserialize(MyClass)` instead of `MyClass.deserialize(deserializer)`.\n   *\n   * @param deserializer - The deserializer instance with the buffered bytes.\n   * @returns The deserialized value of class type T.\n   * @example\n   * ```typescript\n   * const deserializer = new Deserializer(new Uint8Array([1, 2, 3]));\n   * const value = deserializer.deserialize(MyClass); // where MyClass has a `deserialize` function\n   * // value is now an instance of MyClass\n   * // equivalent to `const value = MyClass.deserialize(deserializer)`\n   * ```\n   */\n  deserialize(deserializer: Deserializer): T;\n}\n\n/**\n * A class that provides methods for deserializing various data types from a byte buffer.\n * It supports deserialization of primitive types, strings, and complex objects using a BCS (Binary Common Serialization) layout.\n */\nexport class Deserializer {\n  private buffer: ArrayBuffer;\n\n  private offset: number;\n\n  /**\n   * Creates a new instance of the class with a copy of the provided data buffer.\n   * This prevents outside mutation of the buffer.\n   *\n   * @param data - The data to be copied into the internal buffer as a Uint8Array.\n   */\n  constructor(data: Uint8Array) {\n    // copies data to prevent outside mutation of buffer.\n    this.buffer = new ArrayBuffer(data.length);\n    new Uint8Array(this.buffer).set(data, 0);\n    this.offset = 0;\n  }\n\n  /**\n   * Reads a specified number of bytes from the buffer and advances the offset.\n   *\n   * @param length - The number of bytes to read from the buffer.\n   * @throws Throws an error if the read operation exceeds the buffer's length.\n   */\n  private read(length: number): ArrayBuffer {\n    if (this.offset + length > this.buffer.byteLength) {\n      throw new Error(\"Reached to the end of buffer\");\n    }\n\n    const bytes = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n    return bytes;\n  }\n\n  /**\n   * Returns the number of bytes remaining in the buffer.\n   *\n   * This information is useful to determine if there's more data to be read.\n   *\n   * @returns The number of bytes remaining in the buffer.\n   */\n  remaining(): number {\n    return this.buffer.byteLength - this.offset;\n  }\n\n  /**\n   * @deprecated use `deserializeOption` instead.\n   * Deserializes a UTF-8 encoded string from a byte array. It first reads the length of the string in bytes,\n   * followed by the actual byte content, and decodes it into a string.\n   *\n   * BCS layout for \"string\": string_length | string_content\n   * where string_length is a u32 integer encoded as a uleb128 integer, equal to the number of bytes in string_content.\n   *\n   * @example\n   * ```typescript\n   * const deserializer = new Deserializer(new Uint8Array([8, 49, 50, 51, 52, 97, 98, 99, 100]));\n   * assert(deserializer.deserializeStr() === \"1234abcd\");\n   * ```\n   */\n  deserializeStr(): string {\n    const value = this.deserializeBytes();\n    const textDecoder = new TextDecoder();\n    return textDecoder.decode(value);\n  }\n\n  /**\n   * Deserializes an optional value from the buffer.\n   *\n   * The BCS layout for Optional<T> starts with a boolean byte (0 if none, 1 if some),\n   * followed by the value if present.\n   *\n   * @template T - The type of the value to deserialize\n   * @param type - Either a Deserializable class or one of the string literals: \"string\", \"bytes\", or \"fixedBytes\"\n   * @param len - Required length when type is \"fixedBytes\", ignored otherwise\n   * @returns The deserialized value if present, undefined otherwise\n   *\n   * @throws {Error} When \"fixedBytes\" is specified without a length\n   *\n   * @example\n   * ```typescript\n   * // Deserialize an optional string\n   * const deserializer = new Deserializer(new Uint8Array([1, 3, 97, 98, 99]));\n   * const optStr = deserializer.deserializeOption(\"string\");\n   * // optStr === \"abc\"\n   *\n   * // Deserialize an optional custom type\n   * const deserializer = new Deserializer(new Uint8Array([0]));\n   * const optValue = deserializer.deserializeOption(MyClass);\n   * // optValue === undefined\n   *\n   * // Deserialize optional bytes\n   * const deserializer = new Deserializer(new Uint8Array([1, 3, 1, 2, 3]));\n   * const optBytes = deserializer.deserializeOption(\"bytes\");\n   * // optBytes === Uint8Array[1, 2, 3]\n   *\n   * // Deserialize optional fixed bytes\n   * const deserializer = new Deserializer(new Uint8Array([1, 1, 2, 3, 4]));\n   * const optBytes = deserializer.deserializeOption(\"fixedBytes\", 4);\n   * // optBytes === Uint8Array[1, 2, 3, 4]\n   * ```\n   */\n  deserializeOption(type: \"string\"): string | undefined;\n  deserializeOption(type: \"bytes\"): Uint8Array | undefined;\n  deserializeOption(type: \"fixedBytes\", len: number): Uint8Array | undefined;\n  deserializeOption<T>(type: Deserializable<T>): T | undefined;\n  deserializeOption<T>(\n    type: Deserializable<T> | \"string\" | \"bytes\" | \"fixedBytes\",\n    len?: number,\n  ): T | string | Uint8Array | undefined {\n    const exists = this.deserializeBool();\n    if (!exists) return undefined;\n\n    if (type === \"string\") {\n      return this.deserializeStr();\n    }\n    if (type === \"bytes\") {\n      return this.deserializeBytes();\n    }\n    if (type === \"fixedBytes\") {\n      if (len === undefined) {\n        throw new Error(\"Fixed bytes length not provided\");\n      }\n      return this.deserializeFixedBytes(len);\n    }\n\n    return this.deserialize(type);\n  }\n\n  /**\n   * Deserializes an array of bytes.\n   *\n   * The BCS layout for \"bytes\" consists of a bytes_length followed by the bytes themselves, where bytes_length is a u32 integer\n   * encoded as a uleb128 integer, indicating the length of the bytes array.\n   *\n   * @returns {Uint8Array} The deserialized array of bytes.\n   */\n  deserializeBytes(): Uint8Array {\n    const len = this.deserializeUleb128AsU32();\n    return new Uint8Array(this.read(len));\n  }\n\n  /**\n   * Deserializes an array of bytes of a specified length.\n   *\n   * @param len - The number of bytes to read from the source.\n   */\n  deserializeFixedBytes(len: number): Uint8Array {\n    return new Uint8Array(this.read(len));\n  }\n\n  /**\n   * Deserializes a boolean value from a byte stream.\n   *\n   * The BCS layout for a boolean uses one byte, where \"0x01\" represents true and \"0x00\" represents false.\n   * An error is thrown if the byte value is not valid.\n   *\n   * @returns The deserialized boolean value.\n   * @throws Throws an error if the boolean value is invalid.\n   */\n  deserializeBool(): boolean {\n    const bool = new Uint8Array(this.read(1))[0];\n    if (bool !== 1 && bool !== 0) {\n      throw new Error(\"Invalid boolean value\");\n    }\n    return bool === 1;\n  }\n\n  /**\n   * Deserializes a uint8 number from the binary data.\n   *\n   * BCS layout for \"uint8\": One byte. Binary format in little-endian representation.\n   *\n   * @returns {number} The deserialized uint8 number.\n   */\n  deserializeU8(): Uint8 {\n    return new DataView(this.read(1)).getUint8(0);\n  }\n\n  /**\n   * Deserializes a uint16 number from a binary format in little-endian representation.\n   *\n   * BCS layout for \"uint16\": Two bytes.\n   * @example\n   * ```typescript\n   * const deserializer = new Deserializer(new Uint8Array([0x34, 0x12]));\n   * assert(deserializer.deserializeU16() === 4660);\n   * ```\n   */\n  deserializeU16(): Uint16 {\n    return new DataView(this.read(2)).getUint16(0, true);\n  }\n\n  /**\n   * Deserializes a uint32 number from a binary format in little-endian representation.\n   *\n   * BCS layout for \"uint32\": Four bytes.\n   * @example\n   * ```typescript\n   * const deserializer = new Deserializer(new Uint8Array([0x78, 0x56, 0x34, 0x12]));\n   * assert(deserializer.deserializeU32() === 305419896);\n   * ```\n   */\n  deserializeU32(): Uint32 {\n    return new DataView(this.read(4)).getUint32(0, true);\n  }\n\n  /**\n   * Deserializes a uint64 number.\n   *\n   * This function combines two 32-bit values to return a 64-bit unsigned integer in little-endian representation.\n   * @example\n   * ```typescript\n   * const deserializer = new Deserializer(new Uint8Array([0x00, 0xEF, 0xCD, 0xAB, 0x78, 0x56, 0x34, 0x12]));\n   * assert(deserializer.deserializeU64() === 1311768467750121216);\n   * ```\n   */\n  deserializeU64(): Uint64 {\n    const low = this.deserializeU32();\n    const high = this.deserializeU32();\n\n    // combine the two 32-bit values and return (little endian)\n    return BigInt((BigInt(high) << BigInt(32)) | BigInt(low));\n  }\n\n  /**\n   * Deserializes a uint128 number from its binary representation.\n   * This function combines two 64-bit values to return a single uint128 value in little-endian format.\n   *\n   * @returns {BigInt} The deserialized uint128 number.\n   */\n  deserializeU128(): Uint128 {\n    const low = this.deserializeU64();\n    const high = this.deserializeU64();\n\n    // combine the two 64-bit values and return (little endian)\n    return BigInt((high << BigInt(64)) | low);\n  }\n\n  /**\n   * Deserializes a uint256 number from its binary representation.\n   *\n   * The BCS layout for \"uint256\" consists of thirty-two bytes in little-endian format.\n   *\n   * @returns {BigInt} The deserialized uint256 number.\n   */\n  deserializeU256(): Uint256 {\n    const low = this.deserializeU128();\n    const high = this.deserializeU128();\n\n    // combine the two 128-bit values and return (little endian)\n    return BigInt((high << BigInt(128)) | low);\n  }\n\n  /**\n   * Deserializes a uleb128 encoded uint32 number.\n   *\n   * This function is used for interpreting lengths of variable-length sequences and tags of enum values in BCS encoding.\n   *\n   * @throws {Error} Throws an error if the parsed value exceeds the maximum uint32 number.\n   * @returns {number} The deserialized uint32 value.\n   */\n  deserializeUleb128AsU32(): Uint32 {\n    let value: bigint = BigInt(0);\n    let shift = 0;\n\n    while (value < MAX_U32_NUMBER) {\n      const byte = this.deserializeU8();\n      value |= BigInt(byte & 0x7f) << BigInt(shift);\n\n      if ((byte & 0x80) === 0) {\n        break;\n      }\n      shift += 7;\n    }\n\n    if (value > MAX_U32_NUMBER) {\n      throw new Error(\"Overflow while parsing uleb128-encoded uint32 value\");\n    }\n\n    return Number(value);\n  }\n\n  /**\n   * Helper function that primarily exists to support alternative syntax for deserialization.\n   * That is, if we have a `const deserializer: new Deserializer(...)`, instead of having to use\n   * `MyClass.deserialize(deserializer)`, we can call `deserializer.deserialize(MyClass)`.\n   *\n   * @example const deserializer = new Deserializer(new Uint8Array([1, 2, 3]));\n   * const value = deserializer.deserialize(MyClass); // where MyClass has a `deserialize` function\n   * // value is now an instance of MyClass\n   * // equivalent to `const value = MyClass.deserialize(deserializer)`\n   * @param cls The BCS-deserializable class to deserialize the buffered bytes into.\n   *\n   * @returns the deserialized value of class type T\n   */\n  deserialize<T>(cls: Deserializable<T>): T {\n    // NOTE: `deserialize` in `cls.deserialize(this)` here is a static method defined in `cls`,\n    // It is separate from the `deserialize` instance method defined here in Deserializer.\n    return cls.deserialize(this);\n  }\n\n  /**\n   * Deserializes an array of BCS Deserializable values given an existing Deserializer instance with a loaded byte buffer.\n   *\n   * @param cls The BCS-deserializable class to deserialize the buffered bytes into.\n   * @returns An array of deserialized values of type T.\n   * @example\n   * // serialize a vector of addresses\n   * const addresses = new Array<AccountAddress>(\n   *   AccountAddress.from(\"0x1\"),\n   *   AccountAddress.from(\"0x2\"),\n   *   AccountAddress.from(\"0xa\"),\n   *   AccountAddress.from(\"0xb\"),\n   * );\n   * const serializer = new Serializer();\n   * serializer.serializeVector(addresses);\n   * const serializedBytes = serializer.toUint8Array();\n   *\n   * // deserialize the bytes into an array of addresses\n   * const deserializer = new Deserializer(serializedBytes);\n   * const deserializedAddresses = deserializer.deserializeVector(AccountAddress);\n   * // deserializedAddresses is now an array of AccountAddress instances\n   */\n  deserializeVector<T>(cls: Deserializable<T>): Array<T> {\n    const length = this.deserializeUleb128AsU32();\n    const vector = new Array<T>();\n    for (let i = 0; i < length; i += 1) {\n      vector.push(this.deserialize(cls));\n    }\n    return vector;\n  }\n}\n","// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bytesToHex, hexToBytes } from \"@noble/hashes/utils\";\nimport { ParsingError, ParsingResult } from \"./common\";\nimport { HexInput } from \"../types\";\n\n/**\n * Provides reasons for parsing failures related to hexadecimal values.\n */\nexport enum HexInvalidReason {\n  TOO_SHORT = \"too_short\",\n  INVALID_LENGTH = \"invalid_length\",\n  INVALID_HEX_CHARS = \"invalid_hex_chars\",\n}\n\n/**\n * NOTE: Do not use this class when working with account addresses; use AccountAddress instead.\n * When accepting hex data as input to a function, prefer to accept HexInput and\n *\n * A helper class for working with hex data. Hex data, when represented as a string,\n * generally looks like this, for example: 0xaabbcc, 45cd32, etc.\n *\n * then use the static helper methods of this class to convert it into the desired\n * format. This enables the greatest flexibility for the developer.\n *\n * Example usage:\n * ```typescript\n * getTransactionByHash(txnHash: HexInput): Promise<Transaction> {\n *   const txnHashString = Hex.fromHexInput(txnHash).toString();\n *   return await getTransactionByHashInner(txnHashString);\n * }\n * ```\n * This call to `Hex.fromHexInput().toString()` converts the HexInput to a hex string\n * with a leading 0x prefix, regardless of what the input format was.\n *\n * Other ways to chain the functions together:\n * - `Hex.fromHexString({ hexInput: \"0x1f\" }).toUint8Array()`\n * - `new Hex([1, 3]).toStringWithoutPrefix()`\n */\nexport class Hex {\n  private readonly data: Uint8Array;\n\n  /**\n   * Create a new Hex instance from a Uint8Array.\n   *\n   * @param data - The Uint8Array containing the data to initialize the Hex instance.\n   */\n  constructor(data: Uint8Array) {\n    this.data = data;\n  }\n\n  // ===\n  // Methods for representing an instance of Hex as other types.\n  // ===\n\n  /**\n   * Get the inner hex data as a Uint8Array. The inner data is already a Uint8Array, so no conversion takes place.\n   *\n   * @returns Hex data as Uint8Array\n   */\n  toUint8Array(): Uint8Array {\n    return this.data;\n  }\n\n  /**\n   * Get the hex data as a string without the 0x prefix.\n   *\n   * @returns Hex string without 0x prefix\n   */\n  toStringWithoutPrefix(): string {\n    return bytesToHex(this.data);\n  }\n\n  /**\n   * Get the hex data as a string with the 0x prefix.\n   *\n   * @returns Hex string with 0x prefix\n   */\n  toString(): string {\n    return `0x${this.toStringWithoutPrefix()}`;\n  }\n\n  // ===\n  // Methods for creating an instance of Hex from other types.\n  // ===\n\n  /**\n   * Converts a hex string into a Hex instance, allowing for both prefixed and non-prefixed formats.\n   *\n   * @param str - A hex string, with or without the 0x prefix.\n   *\n   * @throws ParsingError - If the hex string is too short, has an odd number of characters, or contains invalid hex characters.\n   *\n   * @returns Hex - The resulting Hex instance created from the provided string.\n   */\n  static fromHexString(str: string): Hex {\n    let input = str;\n\n    if (input.startsWith(\"0x\")) {\n      input = input.slice(2);\n    }\n\n    if (input.length === 0) {\n      throw new ParsingError(\n        \"Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.\",\n        HexInvalidReason.TOO_SHORT,\n      );\n    }\n\n    if (input.length % 2 !== 0) {\n      throw new ParsingError(\"Hex string must be an even number of hex characters.\", HexInvalidReason.INVALID_LENGTH);\n    }\n\n    try {\n      return new Hex(hexToBytes(input));\n    } catch (error: any) {\n      throw new ParsingError(\n        `Hex string contains invalid hex characters: ${error?.message}`,\n        HexInvalidReason.INVALID_HEX_CHARS,\n      );\n    }\n  }\n\n  /**\n   * Converts an instance of HexInput, which can be a string or a Uint8Array, into a Hex instance.\n   * This function is useful for transforming hexadecimal representations into a structured Hex object for further manipulation.\n   *\n   * @param hexInput - A HexInput which can be a string or Uint8Array.\n   * @returns A Hex instance created from the provided hexInput.\n   */\n  static fromHexInput(hexInput: HexInput): Hex {\n    if (hexInput instanceof Uint8Array) return new Hex(hexInput);\n    return Hex.fromHexString(hexInput);\n  }\n\n  /**\n   * Converts an instance of HexInput, which can be a string or a Uint8Array, into a Uint8Array.\n   *\n   * @param hexInput - A HexInput which can be a string or Uint8Array.\n   * @returns A Uint8Array created from the provided hexInput.\n   */\n  static hexInputToUint8Array(hexInput: HexInput): Uint8Array {\n    if (hexInput instanceof Uint8Array) return hexInput;\n    return Hex.fromHexString(hexInput).toUint8Array();\n  }\n\n  /**\n   * Converts a HexInput (string or Uint8Array) to a hex string with '0x' prefix.\n   *\n   * @param hexInput - The input to convert, either a hex string (with/without '0x' prefix) or Uint8Array\n   * @returns A hex string with '0x' prefix (e.g., \"0x1234\")\n   *\n   * @example\n   * ```typescript\n   * Hex.hexInputToString(\"1234\")        // returns \"0x1234\"\n   * Hex.hexInputToString(\"0x1234\")      // returns \"0x1234\"\n   * Hex.hexInputToString(new Uint8Array([0x12, 0x34])) // returns \"0x1234\"\n   * ```\n   */\n  static hexInputToString(hexInput: HexInput): string {\n    return Hex.fromHexInput(hexInput).toString();\n  }\n\n  /**\n   * Converts a HexInput (string or Uint8Array) to a hex string without '0x' prefix.\n   *\n   * @param hexInput - The input to convert, either a hex string (with/without '0x' prefix) or Uint8Array\n   * @returns A hex string without '0x' prefix (e.g., \"1234\")\n   *\n   * @example\n   * ```typescript\n   * Hex.hexInputToStringWithoutPrefix(\"1234\")        // returns \"1234\"\n   * Hex.hexInputToStringWithoutPrefix(\"0x1234\")      // returns \"1234\"\n   * Hex.hexInputToStringWithoutPrefix(new Uint8Array([0x12, 0x34])) // returns \"1234\"\n   * ```\n   */\n  static hexInputToStringWithoutPrefix(hexInput: HexInput): string {\n    return Hex.fromHexInput(hexInput).toStringWithoutPrefix();\n  }\n\n  // ===\n  // Methods for checking validity.\n  // ===\n\n  /**\n   * Check if the provided string is a valid hexadecimal representation.\n   *\n   * @param str - A hex string representing byte data.\n   *\n   * @returns An object containing:\n   *  - valid: A boolean indicating whether the string is valid.\n   *  - invalidReason: The reason for invalidity if the string is not valid.\n   *  - invalidReasonMessage: A message explaining why the string is invalid.\n   */\n  static isValid(str: string): ParsingResult<HexInvalidReason> {\n    try {\n      Hex.fromHexString(str);\n      return { valid: true };\n    } catch (error: any) {\n      return {\n        valid: false,\n        invalidReason: error?.invalidReason,\n        invalidReasonMessage: error?.message,\n      };\n    }\n  }\n\n  /**\n   * Determine if two Hex instances are equal by comparing their underlying byte data.\n   *\n   * @param other The Hex instance to compare to.\n   * @returns true if the Hex instances are equal, false if not.\n   */\n  equals(other: Hex): boolean {\n    if (this.data.length !== other.data.length) return false;\n    return this.data.every((value, index) => value === other.data[index]);\n  }\n}\n\nexport const hexToAsciiString = (hex: string) => new TextDecoder().decode(Hex.fromHexInput(hex).toUint8Array());\n","// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This error is used to explain why parsing failed.\n */\nexport class ParsingError<T> extends Error {\n  /**\n   * This provides a programmatic way to access why parsing failed. Downstream devs\n   * might want to use this to build their own error messages if the default error\n   * messages are not suitable for their use case. This should be an enum.\n   */\n  public invalidReason: T;\n\n  /**\n   * Creates an instance of the error with a specified message and invalid reason.\n   *\n   * @param message The error message that describes the issue.\n   * @param invalidReason The reason why the input is considered invalid.\n   */\n  constructor(message: string, invalidReason: T) {\n    super(message);\n    this.invalidReason = invalidReason;\n  }\n}\n\n/**\n * Whereas ParsingError is thrown when parsing fails, e.g. in a fromString function,\n * this type is returned from \"defensive\" functions like isValid.\n */\nexport type ParsingResult<T> = {\n  /**\n   * True if valid, false otherwise.\n   */\n  valid: boolean;\n\n  /**\n   * If valid is false, this will be a code explaining why parsing failed.\n   */\n  invalidReason?: T;\n\n  /**\n   * If valid is false, this will be a string explaining why parsing failed.\n   */\n  invalidReasonMessage?: string;\n};\n","// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bytesToHex, hexToBytes } from \"@noble/hashes/utils\";\nimport { Serializable, Serializer } from \"../bcs/serializer\";\nimport { Deserializer } from \"../bcs/deserializer\";\nimport { ParsingError, ParsingResult } from \"./common\";\nimport { TransactionArgument } from \"../transactions/instances/transactionArgument\";\nimport { HexInput, ScriptTransactionArgumentVariants } from \"../types\";\n\n/**\n * Provides reasons for an address was invalid.\n */\nexport enum AddressInvalidReason {\n  INCORRECT_NUMBER_OF_BYTES = \"incorrect_number_of_bytes\",\n  INVALID_HEX_CHARS = \"invalid_hex_chars\",\n  TOO_SHORT = \"too_short\",\n  TOO_LONG = \"too_long\",\n  LEADING_ZERO_X_REQUIRED = \"leading_zero_x_required\",\n  LONG_FORM_REQUIRED_UNLESS_SPECIAL = \"long_form_required_unless_special\",\n  INVALID_PADDING_ZEROES = \"INVALID_PADDING_ZEROES\",\n  INVALID_PADDING_STRICTNESS = \"INVALID_PADDING_STRICTNESS\",\n}\n\n/**\n * The input for an account address, which can be either a hexadecimal string or a standard account address.\n */\nexport type AccountAddressInput = HexInput | AccountAddress;\n\n/**\n * NOTE: Only use this class for account addresses. For other hex data, e.g. transaction\n * hashes, use the Hex class.\n *\n * AccountAddress is used for working with account addresses. Account addresses, when\n * represented as a string, generally look like these examples:\n * - 0x1\n * - 0xaa86fe99004361f747f91342ca13c426ca0cccb0c1217677180c9493bad6ef0c\n *\n * Proper formatting and parsing of account addresses is defined by AIP-40.\n * To learn more about the standard, read the AIP here:\n * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n *\n * The comments in this class make frequent reference to the LONG and SHORT formats,\n * as well as \"special\" addresses. To learn what these refer to see AIP-40.\n */\nexport class AccountAddress extends Serializable implements TransactionArgument {\n  /**\n   * This is the internal representation of an account address.\n   */\n  readonly data: Uint8Array;\n\n  /**\n   * The number of bytes that make up an account address.\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The length of an address string in LONG form without a leading 0x.\n   */\n  static readonly LONG_STRING_LENGTH: number = 64;\n\n  static ZERO: AccountAddress = AccountAddress.from(\"0x0\");\n\n  static ONE: AccountAddress = AccountAddress.from(\"0x1\");\n\n  static TWO: AccountAddress = AccountAddress.from(\"0x2\");\n\n  static THREE: AccountAddress = AccountAddress.from(\"0x3\");\n\n  static FOUR: AccountAddress = AccountAddress.from(\"0x4\");\n\n  static A: AccountAddress = AccountAddress.from(\"0xA\");\n\n  /**\n   * Creates an instance of AccountAddress from a Uint8Array.\n   *\n   * This function ensures that the input data is exactly 32 bytes long, which is required for a valid account address.\n   *\n   * @param input A Uint8Array representing an account address.\n   * @throws ParsingError if the input length is not equal to 32 bytes.\n   */\n  constructor(input: Uint8Array) {\n    super();\n    if (input.length !== AccountAddress.LENGTH) {\n      throw new ParsingError(\n        \"AccountAddress data should be exactly 32 bytes long\",\n        AddressInvalidReason.INCORRECT_NUMBER_OF_BYTES,\n      );\n    }\n    this.data = input;\n  }\n\n  /**\n   * Determines if the address is classified as special, which is defined as 0x0 to 0xf inclusive.\n   * In other words, the last byte of the address must be < 0b10000 (16)\n   * and every other byte must be zero.\n   *\n   * For more information on how special addresses are defined, see AIP-40:\n   * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n   *\n   * @returns true if the address is special, false otherwise.\n   */\n  isSpecial(): boolean {\n    return (\n      this.data.slice(0, this.data.length - 1).every((byte) => byte === 0) && this.data[this.data.length - 1] < 0b10000\n    );\n  }\n  // ===\n  // Methods for representing an instance of AccountAddress as other types.\n  // ===\n\n  /**\n   * Return the AccountAddress as a string as per AIP-40.\n   * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n   * This representation returns special addresses in SHORT form (0xf)\n   * and other addresses in LONG form (0x + 64 characters).\n   *\n   * @returns AccountAddress as a string conforming to AIP-40.\n   */\n  toString(): `0x${string}` {\n    return `0x${this.toStringWithoutPrefix()}`;\n  }\n\n  /**\n   * Return the AccountAddress as a string conforming to AIP-40 but without the leading 0x.\n   *\n   * NOTE: Prefer to use `toString` where possible.\n   *\n   * @returns AccountAddress as a string without the leading 0x.\n   */\n  toStringWithoutPrefix(): string {\n    let hex = bytesToHex(this.data);\n    if (this.isSpecial()) {\n      hex = hex[hex.length - 1];\n    }\n    return hex;\n  }\n\n  /**\n   * Convert the account address to a string in LONG format, which is always 0x followed by 64 hex characters.\n   *\n   * NOTE: Prefer to use `toString` where possible, as it formats special addresses using the SHORT form (no leading 0s).\n   *\n   * @returns AccountAddress as a string in LONG form.\n   */\n  toStringLong(): `0x${string}` {\n    return `0x${this.toStringLongWithoutPrefix()}`;\n  }\n\n  /**\n   * Returns the account address as a string in LONG form without a leading 0x.\n   * This function will include leading zeroes and will produce a string of 64 hex characters.\n   *\n   * NOTE: Prefer to use `toString` where possible, as it formats special addresses using the SHORT form (no leading 0s).\n   *\n   * @returns {string} The account address in LONG form.\n   */\n  toStringLongWithoutPrefix(): string {\n    return bytesToHex(this.data);\n  }\n\n  /**\n   * Get the inner data as a Uint8Array.\n   * The inner data is already a Uint8Array, so no conversion takes place.\n   *\n   * @returns Hex data as Uint8Array\n   */\n  toUint8Array(): Uint8Array {\n    return this.data;\n  }\n\n  /**\n   * Serialize the AccountAddress to a Serializer instance's data buffer.\n   * @param serializer The serializer to serialize the AccountAddress to.\n   * @returns void\n   * @example\n   * const serializer = new Serializer();\n   * const address = AccountAddress.fromString(\"0x1\");\n   * address.serialize(serializer);\n   * const bytes = serializer.toUint8Array();\n   * // `bytes` is now the BCS-serialized address.\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.data);\n  }\n\n  /**\n   * Serializes the current instance into a byte sequence suitable for entry functions.\n   * This allows for the proper encoding of data when interacting with entry functions in the blockchain.\n   *\n   * @param serializer - The serializer instance used to convert the data into bytes.\n   */\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  /**\n   * Serializes the current instance for use in a script function by encoding it into a byte sequence.\n   * This process involves serializing the variant index and the instance data, making it suitable for transmission.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   */\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.Address);\n    serializer.serialize(this);\n  }\n\n  /**\n   * Deserialize an AccountAddress from the byte buffer in a Deserializer instance.\n   * This function allows you to convert a byte representation of an AccountAddress into an instance of AccountAddress.\n   * @param deserializer The deserializer to deserialize the AccountAddress from.\n   * @returns An instance of AccountAddress.\n   * @example\n   * const bytes = hexToBytes(\"0x0102030405060708091011121314151617181920212223242526272829303132\");\n   * const deserializer = new Deserializer(bytes);\n   * const address = AccountAddress.deserialize(deserializer);\n   * // `address` is now an instance of AccountAddress.\n   */\n  static deserialize(deserializer: Deserializer): AccountAddress {\n    const bytes = deserializer.deserializeFixedBytes(AccountAddress.LENGTH);\n    return new AccountAddress(bytes);\n  }\n\n  // ===\n  // Methods for creating an instance of AccountAddress from other types.\n  // ===\n\n  /**\n   * NOTE: This function has strict parsing behavior. For relaxed behavior, please use\n   * the `fromString` function.\n   *\n   * Creates an instance of AccountAddress from a hex string.\n   *\n   * This function allows only the strictest formats defined by AIP-40. In short this\n   * means only the following formats are accepted:\n   *\n   * - LONG\n   * - SHORT for special addresses\n   *\n   * Where:\n   * - LONG is defined as 0x + 64 hex characters.\n   * - SHORT for special addresses is 0x0 to 0xf inclusive without padding zeroes.\n   *\n   * This means the following are not accepted:\n   * - SHORT for non-special addresses.\n   * - Any address without a leading 0x.\n   *\n   * @param input - A hex string representing an account address.\n   *\n   * @throws {ParsingError} If the hex string does not start with 0x or is not in a valid format.\n   *\n   * @remarks\n   *\n   * This function has strict parsing behavior. For relaxed behavior, please use the `fromString` function.\n   *\n   * @see AIP-40 documentation for more details on address formats:\n   * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n   *\n   * @returns An instance of AccountAddress.\n   */\n  static fromStringStrict(input: string): AccountAddress {\n    // Assert the string starts with 0x.\n    if (!input.startsWith(\"0x\")) {\n      throw new ParsingError(\"Hex string must start with a leading 0x.\", AddressInvalidReason.LEADING_ZERO_X_REQUIRED);\n    }\n\n    const address = AccountAddress.fromString(input);\n\n    // Check if the address is in LONG form. If it is not, this is only allowed for\n    // special addresses, in which case we check it is in proper SHORT form.\n    if (input.length !== AccountAddress.LONG_STRING_LENGTH + 2) {\n      if (!address.isSpecial()) {\n        throw new ParsingError(\n          `The given hex string ${input} is not a special address, it must be represented as 0x + 64 chars.`,\n          AddressInvalidReason.LONG_FORM_REQUIRED_UNLESS_SPECIAL,\n        );\n      } else if (input.length !== 3) {\n        // 0x + one hex char is the only valid SHORT form for special addresses.\n        throw new ParsingError(\n          // eslint-disable-next-line max-len\n          `The given hex string ${input} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`,\n          AddressInvalidReason.INVALID_PADDING_ZEROES,\n        );\n      }\n    }\n\n    return address;\n  }\n\n  /**\n   * NOTE: This function has relaxed parsing behavior. For strict behavior, please use\n   * the `fromStringStrict` function. Where possible use `fromStringStrict` rather than this\n   * function, `fromString`.\n   *\n   * Creates an instance of AccountAddress from a hex string.\n   *\n   * This function allows all formats defined by AIP-40. In short this means the\n   * following formats are accepted:\n   *\n   * - LONG, with or without leading 0x\n   * - SHORT*, with or without leading 0x\n   *\n   * Where:\n   * - LONG is 64 hex characters.\n   * - SHORT* is 1 to 63 hex characters inclusive. The address can have missing values up to `maxMissingChars` before it is padded.\n   * - Padding zeroes are allowed, e.g. 0x0123 is valid.\n   *\n   * Learn more about the different address formats by reading AIP-40:\n   * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n   *\n   * @param input A hex string representing an account address.\n   * @param args.maxMissingChars The number of characters that can be missing in a padded address before it is invalid.\n   *\n   * @returns An instance of AccountAddress.\n   *\n   * @throws ParsingError if the hex string is too short, too long, or contains invalid characters.\n   */\n  static fromString(input: string, { maxMissingChars = 4 }: { maxMissingChars?: number } = {}): AccountAddress {\n    let parsedInput = input;\n    // Remove leading 0x for parsing.\n    if (input.startsWith(\"0x\")) {\n      parsedInput = input.slice(2);\n    }\n\n    // Ensure the address string is at least 1 character long.\n    if (parsedInput.length === 0) {\n      throw new ParsingError(\n        \"Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.\",\n        AddressInvalidReason.TOO_SHORT,\n      );\n    }\n\n    // Ensure the address string is not longer than 64 characters.\n    if (parsedInput.length > 64) {\n      throw new ParsingError(\n        \"Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.\",\n        AddressInvalidReason.TOO_LONG,\n      );\n    }\n\n    // Ensure that the maxMissingChars is between or equal to 0 and 63.\n    if (maxMissingChars > 63 || maxMissingChars < 0) {\n      throw new ParsingError(\n        `maxMissingChars must be between or equal to 0 and 63. Received ${maxMissingChars}`,\n        AddressInvalidReason.INVALID_PADDING_STRICTNESS,\n      );\n    }\n\n    let addressBytes: Uint8Array;\n    try {\n      // Pad the address with leading zeroes, so it is 64 chars long and then convert\n      // the hex string to bytes. Every two characters in a hex string constitutes a\n      // single byte. So a 64 length hex string becomes a 32 byte array.\n      addressBytes = hexToBytes(parsedInput.padStart(64, \"0\"));\n    } catch (error: any) {\n      // At this point the only way this can fail is if the hex string contains\n      // invalid characters.\n      throw new ParsingError(`Hex characters are invalid: ${error?.message}`, AddressInvalidReason.INVALID_HEX_CHARS);\n    }\n\n    const address = new AccountAddress(addressBytes);\n\n    // Cannot pad the address if it has more than maxMissingChars missing.\n    if (parsedInput.length < 64 - maxMissingChars) {\n      if (!address.isSpecial()) {\n        throw new ParsingError(\n          `Hex string is too short, must be ${64 - maxMissingChars} to 64 chars long, excluding the leading 0x. You may need to fix \nthe addresss by padding it with 0s before passing it to \\`fromString\\` (e.g. <addressString>.padStart(64, '0')). \nReceived ${input}`,\n          AddressInvalidReason.TOO_SHORT,\n        );\n      }\n    }\n\n    return address;\n  }\n\n  /**\n   * Convenience method for creating an AccountAddress from various input types.\n   * This function accepts a string, Uint8Array, or an existing AccountAddress instance and returns the corresponding\n   * AccountAddress.\n   *\n   * @param input - The input to convert into an AccountAddress. This can be a string representation of an address, a Uint8Array,\n   * or an existing AccountAddress.\n   * @param args.maxMissingChars The number of characters that can be missing in a padded address before it is invalid.\n   */\n  static from(input: AccountAddressInput, { maxMissingChars = 4 }: { maxMissingChars?: number } = {}): AccountAddress {\n    if (typeof input === \"string\") {\n      return AccountAddress.fromString(input, { maxMissingChars });\n    }\n    if (input instanceof Uint8Array) {\n      return new AccountAddress(input);\n    }\n    return input;\n  }\n\n  /**\n   * Create an AccountAddress from various input types, including strings, Uint8Array, and AccountAddress instances.\n   *\n   * @param input - The input to convert into an AccountAddress, which can be a string, a Uint8Array, or an AccountAddress.\n   */\n  static fromStrict(input: AccountAddressInput): AccountAddress {\n    if (typeof input === \"string\") {\n      return AccountAddress.fromStringStrict(input);\n    }\n    if (input instanceof Uint8Array) {\n      return new AccountAddress(input);\n    }\n    return input;\n  }\n  // ===\n  // Methods for checking validity.\n  // ===\n\n  /**\n   * Check if the provided input is a valid AccountAddress.\n   *\n   * @param args - The arguments for validation.\n   * @param args.input - A hex string representing an account address.\n   * @param args.strict - If true, use strict parsing behavior; if false, use relaxed parsing behavior.\n   *\n   * @returns An object indicating whether the address is valid. If valid, valid = true; if not, valid = false with additional details.\n   * If the address is invalid, invalidReason will explain why it is invalid, and invalidReasonMessage will provide the error message.\n   */\n  static isValid(args: { input: AccountAddressInput; strict?: boolean }): ParsingResult<AddressInvalidReason> {\n    try {\n      if (args.strict) {\n        AccountAddress.fromStrict(args.input);\n      } else {\n        AccountAddress.from(args.input);\n      }\n      return { valid: true };\n    } catch (error: any) {\n      return {\n        valid: false,\n        invalidReason: error?.invalidReason,\n        invalidReasonMessage: error?.message,\n      };\n    }\n  }\n\n  /**\n   * Determine if two AccountAddresses are equal based on their underlying byte data.\n   *\n   * @param other - The AccountAddress to compare to.\n   * @returns true if the AccountAddresses are equal, false if not.\n   */\n  equals(other: AccountAddress): boolean {\n    if (this.data.length !== other.data.length) return false;\n    return this.data.every((value, index) => value === other.data[index]);\n  }\n}\n","/* eslint-disable max-len */\n\nimport { HexInput, PrivateKeyVariants } from \"../../types\";\nimport { Hex } from \"../hex\";\nimport { PublicKey } from \"./publicKey\";\nimport { Signature } from \"./signature\";\n\n/**\n * Represents a private key used for signing messages and deriving the associated public key.\n */\nexport interface PrivateKey {\n  /**\n   * Sign the given message with the private key to create a signature.\n   * @param message - The message to be signed, provided in HexInput format.\n   * @returns A Signature object representing the signed message.\n   */\n  sign(message: HexInput): Signature;\n\n  /**\n   * Derive the public key associated with the private key.\n   */\n  publicKey(): PublicKey;\n\n  /**\n   * Get the private key in bytes (Uint8Array).\n   */\n  toUint8Array(): Uint8Array;\n}\n\nexport class PrivateKey {\n  /**\n   * The AIP-80 compliant prefixes for each private key type. Append this to a private key's hex representation\n   * to get an AIP-80 compliant string.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   */\n  public static readonly AIP80_PREFIXES = {\n    [PrivateKeyVariants.Ed25519]: \"ed25519-priv-\",\n    [PrivateKeyVariants.Secp256k1]: \"secp256k1-priv-\",\n  };\n\n  /**\n   * Format a HexInput to an AIP-80 compliant string.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   *\n   * @param privateKey - The HexString or Uint8Array format of the private key.\n   * @param privateKeyType - The private key type\n   */\n  public static formatPrivateKey(privateKey: HexInput, type: PrivateKeyVariants): string {\n    const aip80Prefix = PrivateKey.AIP80_PREFIXES[type];\n    return `${aip80Prefix}${Hex.fromHexInput(privateKey).toString()}`;\n  }\n\n  /**\n   * Parse a HexInput that may be a HexString, Uint8Array, or a AIP-80 compliant string to a Hex instance.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   *\n   * @param value - A HexString, Uint8Array, or a AIP-80 compliant string.\n   * @param privateKeyType - The private key type\n   * @param strict - If true, the value MUST be compliant with AIP-80.\n   */\n  public static parseHexInput(value: HexInput, type: PrivateKeyVariants, strict?: boolean): Hex {\n    let data: Hex;\n\n    const aip80Prefix = PrivateKey.AIP80_PREFIXES[type];\n    if (typeof value === \"string\") {\n      if (!strict && !value.startsWith(aip80Prefix)) {\n        // HexString input\n        data = Hex.fromHexInput(value);\n        // If the strictness is false, the user has opted into non-AIP-80 compliant private keys.\n        if (strict !== false) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            \"[Aptos SDK] It is recommended that private keys are AIP-80 compliant (https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md). You can fix the private key by formatting it with `PrivateKey.formatPrivateKey(privateKey: string, type: 'ed25519' | 'secp256k1'): string`.\",\n          );\n        }\n      } else if (value.startsWith(aip80Prefix)) {\n        // AIP-80 Compliant String input\n        data = Hex.fromHexString(value.split(\"-\")[2]);\n      } else {\n        if (strict) {\n          // The value does not start with the AIP-80 prefix, and strict is true.\n          throw new Error(\"Invalid HexString input while parsing private key. Must AIP-80 compliant string.\");\n        }\n\n        // This condition should never be reached.\n        throw new Error(\"Invalid HexString input while parsing private key.\");\n      }\n    } else {\n      // The value is an Uint8Array\n      data = Hex.fromHexInput(value);\n      // If the strictness is false, the user has opted into non-AIP-80 compliant private keys.\n      if (strict !== false) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          \"[Aptos SDK] It is recommended that private keys are parsed as AIP-80 compliant strings instead of Uint8Array (https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md). You can fix the private key by formatting it with `PrivateKey.formatPrivateKey(privateKey: Uint8Array, type: 'ed25519' | 'secp256k1'): string`.\",\n        );\n      }\n    }\n\n    return data;\n  }\n}\n","import { AptosApiType } from \"../utils/const\";\nimport { getErrorMessage } from \"../utils/helpers\";\nimport { AptosRequest, AptosResponse } from \"../types\";\n\nexport enum KeylessErrorCategory {\n  API_ERROR,\n  EXTERNAL_API_ERROR,\n  SESSION_EXPIRED,\n  INVALID_STATE,\n  UNKNOWN,\n}\n\nexport enum KeylessErrorResolutionTip {\n  REAUTHENTICATE = \"Re-authentiate to continue using your keyless account\",\n  // eslint-disable-next-line max-len\n  REAUTHENTICATE_UNSURE = \"Try re-authentiating. If the error persists join the telegram group at https://t.me/+h5CN-W35yUFiYzkx for further support\",\n  UPDATE_REQUEST_PARAMS = \"Update the invalid request parameters and reauthenticate.\",\n  // eslint-disable-next-line max-len\n  RATE_LIMIT_EXCEEDED = \"Cache the keyless account and reuse it to avoid making too many requests.  Keyless accounts are valid until either the EphemeralKeyPair expires, when the JWK is rotated, or when the proof verifying key is changed, whichever comes soonest.\",\n  // eslint-disable-next-line max-len\n  SERVER_ERROR = \"Try again later.  See aptosApiError error for more context. For additional support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx\",\n  // eslint-disable-next-line max-len\n  CALL_PRECHECK = \"Call `await account.checkKeylessAccountValidity()` to wait for asyncronous changes and check for account validity before signing or serializing.\",\n  REINSTANTIATE = \"Try instantiating the account again.  Avoid manipulating the account object directly\",\n  JOIN_SUPPORT_GROUP = \"For support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx\",\n  UNKNOWN = \"Error unknown. For support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx\",\n}\n\nexport enum KeylessErrorType {\n  EPHEMERAL_KEY_PAIR_EXPIRED,\n\n  PROOF_NOT_FOUND,\n\n  ASYNC_PROOF_FETCH_FAILED,\n\n  INVALID_PROOF_VERIFICATION_FAILED,\n\n  INVALID_PROOF_VERIFICATION_KEY_NOT_FOUND,\n\n  INVALID_JWT_SIG,\n\n  INVALID_JWT_JWK_NOT_FOUND,\n\n  INVALID_JWT_ISS_NOT_RECOGNIZED,\n\n  INVALID_JWT_FEDERATED_ISS_NOT_SUPPORTED,\n\n  INVALID_TW_SIG_VERIFICATION_FAILED,\n\n  INVALID_TW_SIG_PUBLIC_KEY_NOT_FOUND,\n\n  INVALID_EXPIRY_HORIZON,\n\n  JWT_PARSING_ERROR,\n\n  JWK_FETCH_FAILED,\n\n  JWK_FETCH_FAILED_FEDERATED,\n\n  RATE_LIMIT_EXCEEDED,\n\n  PEPPER_SERVICE_INTERNAL_ERROR,\n\n  PEPPER_SERVICE_BAD_REQUEST,\n\n  PEPPER_SERVICE_OTHER,\n\n  PROVER_SERVICE_INTERNAL_ERROR,\n\n  PROVER_SERVICE_BAD_REQUEST,\n\n  PROVER_SERVICE_OTHER,\n\n  FULL_NODE_CONFIG_LOOKUP_ERROR,\n\n  FULL_NODE_VERIFICATION_KEY_LOOKUP_ERROR,\n\n  FULL_NODE_JWKS_LOOKUP_ERROR,\n\n  FULL_NODE_OTHER,\n\n  UNKNOWN,\n}\n\nconst KeylessErrors: { [key in KeylessErrorType]: [string, KeylessErrorCategory, KeylessErrorResolutionTip] } = {\n  [KeylessErrorType.EPHEMERAL_KEY_PAIR_EXPIRED]: [\n    \"The ephemeral keypair has expired.\",\n    KeylessErrorCategory.SESSION_EXPIRED,\n    KeylessErrorResolutionTip.REAUTHENTICATE,\n  ],\n  [KeylessErrorType.PROOF_NOT_FOUND]: [\n    \"The required proof could not be found.\",\n    KeylessErrorCategory.INVALID_STATE,\n    KeylessErrorResolutionTip.CALL_PRECHECK,\n  ],\n  [KeylessErrorType.ASYNC_PROOF_FETCH_FAILED]: [\n    \"The required proof failed to fetch.\",\n    KeylessErrorCategory.INVALID_STATE,\n    KeylessErrorResolutionTip.REAUTHENTICATE_UNSURE,\n  ],\n  [KeylessErrorType.INVALID_PROOF_VERIFICATION_FAILED]: [\n    \"The provided proof is invalid.\",\n    KeylessErrorCategory.INVALID_STATE,\n    KeylessErrorResolutionTip.REAUTHENTICATE_UNSURE,\n  ],\n  [KeylessErrorType.INVALID_PROOF_VERIFICATION_KEY_NOT_FOUND]: [\n    \"The verification key used to authenticate was updated.\",\n    KeylessErrorCategory.SESSION_EXPIRED,\n    KeylessErrorResolutionTip.REAUTHENTICATE,\n  ],\n  [KeylessErrorType.INVALID_JWT_SIG]: [\n    \"The JWK was found, but JWT failed verification\",\n    KeylessErrorCategory.INVALID_STATE,\n    KeylessErrorResolutionTip.REAUTHENTICATE_UNSURE,\n  ],\n  [KeylessErrorType.INVALID_JWT_JWK_NOT_FOUND]: [\n    \"The JWK required to verify the JWT could not be found. The JWK may have been rotated out.\",\n    KeylessErrorCategory.SESSION_EXPIRED,\n    KeylessErrorResolutionTip.REAUTHENTICATE,\n  ],\n  [KeylessErrorType.INVALID_JWT_ISS_NOT_RECOGNIZED]: [\n    \"The JWT issuer is not recognized.\",\n    KeylessErrorCategory.INVALID_STATE,\n    KeylessErrorResolutionTip.UPDATE_REQUEST_PARAMS,\n  ],\n  [KeylessErrorType.INVALID_JWT_FEDERATED_ISS_NOT_SUPPORTED]: [\n    \"The JWT issuer is not supported by the Federated Keyless \",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.REAUTHENTICATE_UNSURE,\n  ],\n  [KeylessErrorType.INVALID_TW_SIG_VERIFICATION_FAILED]: [\n    \"The training wheels signature is invalid.\",\n    KeylessErrorCategory.INVALID_STATE,\n    KeylessErrorResolutionTip.REAUTHENTICATE_UNSURE,\n  ],\n  [KeylessErrorType.INVALID_TW_SIG_PUBLIC_KEY_NOT_FOUND]: [\n    \"The public key used to verify the training wheels signature was not found.\",\n    KeylessErrorCategory.SESSION_EXPIRED,\n    KeylessErrorResolutionTip.REAUTHENTICATE,\n  ],\n  [KeylessErrorType.INVALID_EXPIRY_HORIZON]: [\n    \"The expiry horizon is invalid.\",\n    KeylessErrorCategory.SESSION_EXPIRED,\n    KeylessErrorResolutionTip.REAUTHENTICATE,\n  ],\n  [KeylessErrorType.JWK_FETCH_FAILED]: [\n    \"Failed to fetch JWKS.\",\n    KeylessErrorCategory.EXTERNAL_API_ERROR,\n    KeylessErrorResolutionTip.JOIN_SUPPORT_GROUP,\n  ],\n  [KeylessErrorType.JWK_FETCH_FAILED_FEDERATED]: [\n    \"Failed to fetch JWKS for Federated Keyless provider.\",\n    KeylessErrorCategory.EXTERNAL_API_ERROR,\n    KeylessErrorResolutionTip.JOIN_SUPPORT_GROUP,\n  ],\n  [KeylessErrorType.RATE_LIMIT_EXCEEDED]: [\n    \"Rate limit exceeded. Too many requests in a short period.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.RATE_LIMIT_EXCEEDED,\n  ],\n  [KeylessErrorType.PEPPER_SERVICE_INTERNAL_ERROR]: [\n    \"Internal error from Pepper service.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.SERVER_ERROR,\n  ],\n  [KeylessErrorType.PEPPER_SERVICE_BAD_REQUEST]: [\n    \"Bad request sent to Pepper service.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.UPDATE_REQUEST_PARAMS,\n  ],\n  [KeylessErrorType.PEPPER_SERVICE_OTHER]: [\n    \"Unknown error from Pepper service.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.SERVER_ERROR,\n  ],\n  [KeylessErrorType.PROVER_SERVICE_INTERNAL_ERROR]: [\n    \"Internal error from Prover service.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.SERVER_ERROR,\n  ],\n  [KeylessErrorType.PROVER_SERVICE_BAD_REQUEST]: [\n    \"Bad request sent to Prover service.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.UPDATE_REQUEST_PARAMS,\n  ],\n  [KeylessErrorType.PROVER_SERVICE_OTHER]: [\n    \"Unknown error from Prover service.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.SERVER_ERROR,\n  ],\n  [KeylessErrorType.JWT_PARSING_ERROR]: [\n    \"Error when parsing JWT. This should never happen. Join https://t.me/+h5CN-W35yUFiYzkx for support\",\n    KeylessErrorCategory.INVALID_STATE,\n    KeylessErrorResolutionTip.REINSTANTIATE,\n  ],\n  [KeylessErrorType.FULL_NODE_CONFIG_LOOKUP_ERROR]: [\n    \"Error when looking up on-chain keyless configuration.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.SERVER_ERROR,\n  ],\n  [KeylessErrorType.FULL_NODE_VERIFICATION_KEY_LOOKUP_ERROR]: [\n    \"Error when looking up on-chain verification key.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.SERVER_ERROR,\n  ],\n  [KeylessErrorType.FULL_NODE_JWKS_LOOKUP_ERROR]: [\n    \"Error when looking up on-chain JWKS.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.SERVER_ERROR,\n  ],\n  [KeylessErrorType.FULL_NODE_OTHER]: [\n    \"Unknown error from full node.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.SERVER_ERROR,\n  ],\n  [KeylessErrorType.UNKNOWN]: [\n    \"An unknown error has occurred.\",\n    KeylessErrorCategory.UNKNOWN,\n    KeylessErrorResolutionTip.UNKNOWN,\n  ],\n};\n\nexport class KeylessError extends Error {\n  readonly innerError?: unknown;\n\n  readonly category: KeylessErrorCategory;\n\n  readonly resolutionTip: KeylessErrorResolutionTip;\n\n  readonly type: KeylessErrorType;\n\n  readonly details?: string;\n\n  /** @internal this constructor is for sdk internal use - do not instantiate outside of the SDK codebase */\n  constructor(args: {\n    innerError?: unknown;\n    category: KeylessErrorCategory;\n    resolutionTip: KeylessErrorResolutionTip;\n    type: KeylessErrorType;\n    message?: string;\n    details?: string;\n  }) {\n    const { innerError, category, resolutionTip, type, message = KeylessErrors[type][0], details } = args;\n    super(message);\n    this.name = \"KeylessError\";\n    this.innerError = innerError;\n    this.category = category;\n    this.resolutionTip = resolutionTip;\n    this.type = type;\n    this.details = details;\n    this.message = KeylessError.constructMessage(message, resolutionTip, innerError, details);\n  }\n\n  static constructMessage(\n    message: string,\n    tip: KeylessErrorResolutionTip,\n    innerError?: unknown,\n    details?: string,\n  ): string {\n    let result = `\\nMessage: ${message}`;\n    if (details) {\n      result += `\\nDetails: ${details}`;\n    }\n    if (innerError instanceof AptosApiError) {\n      result += `\\nAptosApiError: ${innerError.message}`;\n    } else if (innerError !== undefined) {\n      result += `\\nError: ${getErrorMessage(innerError)}`;\n    }\n    result += `\\nKeylessErrorResolutionTip: ${tip}`;\n    return result;\n  }\n\n  /**\n   * Static constructor that creates a KeylessError instance using the KeylessErrors constant\n   * @param args.type The type of KeylessError\n   * @param args.aptosApiError optional AptosApiError supplied for api errors\n   * @param args.details optional details to include in the error message\n   * @returns A new KeylessError instance\n   */\n  static fromErrorType(args: { type: KeylessErrorType; error?: unknown; details?: string }): KeylessError {\n    const { error, type, details } = args;\n\n    const [message, category, resolutionTip] = KeylessErrors[type];\n    return new KeylessError({\n      message,\n      details,\n      innerError: error,\n      category,\n      resolutionTip,\n      type,\n    });\n  }\n}\n\n/**\n * Options for handling errors in the Aptos API.\n */\ntype AptosApiErrorOpts = {\n  apiType: AptosApiType;\n  aptosRequest: AptosRequest;\n  aptosResponse: AptosResponse<any, any>;\n};\n\n/**\n * Represents an error returned from the Aptos API.\n * This class encapsulates the details of the error, including the request URL, response status, and additional data.\n *\n * @param name - The name of the error, which is always \"AptosApiError\".\n * @param url - The URL to which the request was made.\n * @param status - The HTTP response status code (e.g., 400).\n * @param statusText - The message associated with the response status.\n * @param data - The response data returned from the API.\n * @param request - The original AptosRequest that triggered the error.\n */\nexport class AptosApiError extends Error {\n  readonly url: string;\n\n  readonly status: number;\n\n  readonly statusText: string;\n\n  readonly data: any;\n\n  readonly request: AptosRequest;\n\n  /**\n   * Constructs an instance of AptosApiError with relevant error details.\n   *\n   * @param opts - The options for creating the AptosApiError.\n   * @param opts.apiType - The type of API that generated the error.\n   * @param opts.aptosRequest - The request object that caused the error.\n   * @param opts.aptosResponse - The response object containing error details.\n   *\n   * @internal This constructor is for SDK internal use - do not instantiate outside the SDK codebase.\n   */\n  constructor({ apiType, aptosRequest, aptosResponse }: AptosApiErrorOpts) {\n    super(deriveErrorMessage({ apiType, aptosRequest, aptosResponse }));\n\n    this.name = \"AptosApiError\";\n    this.url = aptosResponse.url;\n    this.status = aptosResponse.status;\n    this.statusText = aptosResponse.statusText;\n    this.data = aptosResponse.data;\n    this.request = aptosRequest;\n  }\n}\n\n/**\n * Derives an error message from the Aptos API response, providing context for debugging.\n * This function helps in understanding the nature of the error encountered during an API request.\n *\n * @param {AptosApiErrorOpts} opts - The options for deriving the error message.\n * @param {AptosApiType} opts.apiType - The type of API being called.\n * @param {AptosRequest} opts.aptosRequest - The original request made to the Aptos API.\n * @param {AptosResponse} opts.aptosResponse - The response received from the Aptos API.\n */\nfunction deriveErrorMessage({ apiType, aptosRequest, aptosResponse }: AptosApiErrorOpts): string {\n  // eslint-disable-next-line max-len\n  // extract the W3C trace_id from the response headers if it exists. Some services set this in the response, and it's useful for debugging.\n  // See https://www.w3.org/TR/trace-context/#relationship-between-the-headers .\n  const traceId = aptosResponse.headers?.traceparent?.split(\"-\")[1];\n  const traceIdString = traceId ? `(trace_id:${traceId}) ` : \"\";\n\n  const errorPrelude: string = `Request to [${apiType}]: ${aptosRequest.method} ${\n    aptosResponse.url ?? aptosRequest.url\n  } ${traceIdString}failed with`;\n\n  // handle graphql responses from indexer api and extract the error message of the first error\n  if (apiType === AptosApiType.INDEXER && aptosResponse.data?.errors?.[0]?.message != null) {\n    return `${errorPrelude}: ${aptosResponse.data.errors[0].message}`;\n  }\n\n  // Received well-known structured error response body - simply serialize and return it.\n  // We don't need http status codes etc. in this case.\n  if (aptosResponse.data?.message != null && aptosResponse.data?.error_code != null) {\n    return `${errorPrelude}: ${JSON.stringify(aptosResponse.data)}`;\n  }\n\n  // This is the generic/catch-all case. We received some response from the API, but it doesn't appear to be a well-known structure.\n  // We print http status codes and the response body (after some trimming),\n  // in the hope that this gives enough context what went wrong without printing overly huge messages.\n  return `${errorPrelude} status: ${aptosResponse.statusText}(code:${\n    aptosResponse.status\n  }) and response body: ${serializeAnyPayloadForErrorMessage(aptosResponse.data)}`;\n}\n\nconst SERIALIZED_PAYLOAD_TRIM_TO_MAX_LENGTH = 400;\n\n/**\n * This function accepts a payload of any type (probably an object) and serializes it to a string\n * Since we don't know the type or size of the payload, and we don't want to add a huge object in full to the error message\n * we limit the to the first 200 and last 200 characters of the serialized payload and put a \"...\" in the middle.\n * @param payload - The payload to serialize, which can be of any type.\n *\n * @returns A string representation of the serialized payload, potentially truncated.\n */\nfunction serializeAnyPayloadForErrorMessage(payload: any): string {\n  const serializedPayload = JSON.stringify(payload);\n  if (serializedPayload.length <= SERIALIZED_PAYLOAD_TRIM_TO_MAX_LENGTH) {\n    return serializedPayload;\n  }\n  return `truncated(original_size:${serializedPayload.length}): ${serializedPayload.slice(\n    0,\n    SERIALIZED_PAYLOAD_TRIM_TO_MAX_LENGTH / 2,\n  )}...${serializedPayload.slice(-SERIALIZED_PAYLOAD_TRIM_TO_MAX_LENGTH / 2)}`;\n}\n","import { AptosConfig } from \"../api/aptosConfig\";\nimport { aptosRequest } from \"./core\";\nimport { AptosResponse, AnyNumber, ClientConfig, MimeType } from \"../types\";\nimport { AptosApiType } from \"../utils/const\";\n\n/**\n * Options for making a GET request, including configuration for the API client.\n */\nexport type GetRequestOptions = {\n  /**\n   * The config for the API client\n   */\n  aptosConfig: AptosConfig;\n  /**\n   * The type of API endpoint to call e.g. fullnode, indexer, etc\n   */\n  type: AptosApiType;\n  /**\n   * The name of the API method\n   */\n  originMethod: string;\n  /**\n   * The URL path to the API method\n   */\n  path: string;\n  /**\n   * The content type of the request body\n   */\n  contentType?: MimeType;\n  /**\n   * The accepted content type of the response of the API\n   */\n  acceptType?: MimeType;\n  /**\n   * The query parameters for the request\n   */\n  params?: Record<string, string | AnyNumber | boolean | undefined>;\n  /**\n   * Specific client overrides for this request to override aptosConfig\n   */\n  overrides?: ClientConfig;\n};\n\n/**\n * Options for making a request to the Aptos API, excluding the \"type\" field.\n */\nexport type GetAptosRequestOptions = Omit<GetRequestOptions, \"type\">;\n\n/**\n * Executes a GET request to retrieve data based on the provided options.\n *\n * @param options - The options for the GET request.\n * @param options.aptosConfig - The configuration object for Aptos requests.\n * @param options.overrides - Optional overrides for the request configuration.\n * @param options.params - Query parameters to include in the request.\n * @param options.contentType - The content type of the request.\n * @param options.acceptType - The accepted response type.\n * @param options.path - The specific path for the request.\n * @param options.originMethod - The original method of the request.\n * @param options.type - The type of request being made.\n * @returns The response from the GET request.\n */\nexport async function get<Req extends {}, Res extends {}>(\n  options: GetRequestOptions,\n): Promise<AptosResponse<Req, Res>> {\n  const { aptosConfig, overrides, params, contentType, acceptType, path, originMethod, type } = options;\n  const url = aptosConfig.getRequestUrl(type);\n\n  return aptosRequest<Req, Res>(\n    {\n      url,\n      method: \"GET\",\n      originMethod,\n      path,\n      contentType,\n      acceptType,\n      params,\n      overrides: {\n        ...aptosConfig.clientConfig,\n        ...overrides,\n      },\n    },\n    aptosConfig,\n    options.type,\n  );\n}\n\n/**\n * Retrieves data from the Aptos full node using the provided options.\n *\n * @param options - The options for the request to the Aptos full node.\n * @param options.aptosConfig - Configuration settings specific to the Aptos client and full node.\n * @param options.aptosConfig.clientConfig - The client configuration settings.\n * @param options.aptosConfig.fullnodeConfig - The full node configuration settings.\n * @param options.overrides - Additional overrides for the request.\n * @param options.type - The type of API request being made.\n *\n * @returns A promise that resolves with the response from the Aptos full node.\n */\nexport async function getAptosFullNode<Req extends {}, Res extends {}>(\n  options: GetAptosRequestOptions,\n): Promise<AptosResponse<Req, Res>> {\n  const { aptosConfig } = options;\n\n  return get<Req, Res>({\n    ...options,\n    type: AptosApiType.FULLNODE,\n    overrides: {\n      ...aptosConfig.clientConfig,\n      ...aptosConfig.fullnodeConfig,\n      ...options.overrides,\n      HEADERS: { ...aptosConfig.clientConfig?.HEADERS, ...aptosConfig.fullnodeConfig?.HEADERS },\n    },\n  });\n}\n\n/**\n * Makes a GET request to the Aptos Pepper service to retrieve data.\n *\n * @param options - The options for the request.\n * @param options.param1 - Description of param1.\n * @param options.param2 - Description of param2.\n * @returns AptosResponse - The response from the Aptos Pepper service.\n */\nexport async function getAptosPepperService<Req extends {}, Res extends {}>(\n  options: GetAptosRequestOptions,\n): Promise<AptosResponse<Req, Res>> {\n  return get<Req, Res>({ ...options, type: AptosApiType.PEPPER });\n}\n\n/// This function is a helper for paginating using a function wrapping an API\nexport async function paginateWithCursor<Req extends Record<string, any>, Res extends Array<{}>>(\n  options: GetAptosRequestOptions,\n): Promise<Res> {\n  const out: any[] = [];\n  let cursor: string | undefined;\n  const requestParams = options.params as { start?: string; limit?: number };\n  do {\n    // eslint-disable-next-line no-await-in-loop\n    const response = await get<Req, Res>({\n      type: AptosApiType.FULLNODE,\n      aptosConfig: options.aptosConfig,\n      originMethod: options.originMethod,\n      path: options.path,\n      params: requestParams,\n      overrides: options.overrides,\n    });\n    /**\n     * the cursor is a \"state key\" from the API perspective. Client\n     * should not need to \"care\" what it represents but just use it\n     * to query the next chunk of data.\n     */\n    cursor = response.headers[\"x-aptos-cursor\"];\n    // Now that we have the cursor (if any), we remove the headers before\n    // adding these to the output of this function.\n    delete response.headers;\n    out.push(...response.data);\n    requestParams.start = cursor;\n  } while (cursor !== null && cursor !== undefined);\n  return out as Res;\n}\n","import * as Types from \"./operations\";\n\nimport { GraphQLClient, RequestOptions } from \"graphql-request\";\ntype GraphQLClientRequestHeaders = RequestOptions[\"requestHeaders\"];\nexport const TokenActivitiesFieldsFragmentDoc = `\n    fragment TokenActivitiesFields on token_activities_v2 {\n  after_value\n  before_value\n  entry_function_id_str\n  event_account_address\n  event_index\n  from_address\n  is_fungible_v2\n  property_version_v1\n  to_address\n  token_amount\n  token_data_id\n  token_standard\n  transaction_timestamp\n  transaction_version\n  type\n}\n    `;\nexport const AnsTokenFragmentFragmentDoc = `\n    fragment AnsTokenFragment on current_aptos_names {\n  domain\n  expiration_timestamp\n  registered_address\n  subdomain\n  token_standard\n  is_primary\n  owner_address\n  subdomain_expiration_policy\n  domain_expiration_timestamp\n}\n    `;\nexport const CurrentTokenOwnershipFieldsFragmentDoc = `\n    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {\n  token_standard\n  token_properties_mutated_v1\n  token_data_id\n  table_type_v1\n  storage_id\n  property_version_v1\n  owner_address\n  last_transaction_version\n  last_transaction_timestamp\n  is_soulbound_v2\n  is_fungible_v2\n  amount\n  current_token_data {\n    collection_id\n    description\n    is_fungible_v2\n    largest_property_version_v1\n    last_transaction_timestamp\n    last_transaction_version\n    maximum\n    supply\n    token_data_id\n    token_name\n    token_properties\n    token_standard\n    token_uri\n    decimals\n    current_collection {\n      collection_id\n      collection_name\n      creator_address\n      current_supply\n      description\n      last_transaction_timestamp\n      last_transaction_version\n      max_supply\n      mutable_description\n      mutable_uri\n      table_handle_v1\n      token_standard\n      total_minted_v2\n      uri\n    }\n  }\n}\n    `;\nexport const GetAccountCoinsCount = `\n    query getAccountCoinsCount($address: String) {\n  current_fungible_asset_balances_aggregate(\n    where: {owner_address: {_eq: $address}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n    `;\nexport const GetAccountCoinsData = `\n    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {\n  current_fungible_asset_balances(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    amount\n    asset_type\n    is_frozen\n    is_primary\n    last_transaction_timestamp\n    last_transaction_version\n    owner_address\n    storage_id\n    token_standard\n    metadata {\n      token_standard\n      symbol\n      supply_aggregator_table_key_v1\n      supply_aggregator_table_handle_v1\n      project_uri\n      name\n      last_transaction_version\n      last_transaction_timestamp\n      icon_uri\n      decimals\n      creator_address\n      asset_type\n    }\n  }\n}\n    `;\nexport const GetAccountCollectionsWithOwnedTokens = `\n    query getAccountCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {\n  current_collection_ownership_v2_view(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    current_collection {\n      collection_id\n      collection_name\n      creator_address\n      current_supply\n      description\n      last_transaction_timestamp\n      last_transaction_version\n      mutable_description\n      max_supply\n      mutable_uri\n      table_handle_v1\n      token_standard\n      total_minted_v2\n      uri\n    }\n    collection_id\n    collection_name\n    collection_uri\n    creator_address\n    distinct_tokens\n    last_transaction_version\n    owner_address\n    single_token_uri\n  }\n}\n    `;\nexport const GetAccountOwnedTokens = `\n    query getAccountOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nexport const GetAccountOwnedTokensByTokenData = `\n    query getAccountOwnedTokensByTokenData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nexport const GetAccountOwnedTokensFromCollection = `\n    query getAccountOwnedTokensFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nexport const GetAccountTokensCount = `\n    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {\n  current_token_ownerships_v2_aggregate(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n    `;\nexport const GetAccountTransactionsCount = `\n    query getAccountTransactionsCount($address: String) {\n  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {\n    aggregate {\n      count\n    }\n  }\n}\n    `;\nexport const GetChainTopUserTransactions = `\n    query getChainTopUserTransactions($limit: Int) {\n  user_transactions(limit: $limit, order_by: {version: desc}) {\n    version\n  }\n}\n    `;\nexport const GetCollectionData = `\n    query getCollectionData($where_condition: current_collections_v2_bool_exp!) {\n  current_collections_v2(where: $where_condition) {\n    uri\n    total_minted_v2\n    token_standard\n    table_handle_v1\n    mutable_uri\n    mutable_description\n    max_supply\n    collection_id\n    collection_name\n    creator_address\n    current_supply\n    description\n    last_transaction_timestamp\n    last_transaction_version\n    cdn_asset_uris {\n      cdn_image_uri\n      asset_uri\n      animation_optimizer_retry_count\n      cdn_animation_uri\n      cdn_json_uri\n      image_optimizer_retry_count\n      json_parser_retry_count\n      raw_animation_uri\n      raw_image_uri\n    }\n  }\n}\n    `;\nexport const GetCurrentFungibleAssetBalances = `\n    query getCurrentFungibleAssetBalances($where_condition: current_fungible_asset_balances_bool_exp, $offset: Int, $limit: Int) {\n  current_fungible_asset_balances(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n  ) {\n    amount\n    asset_type\n    is_frozen\n    is_primary\n    last_transaction_timestamp\n    last_transaction_version\n    owner_address\n    storage_id\n    token_standard\n  }\n}\n    `;\nexport const GetDelegatedStakingActivities = `\n    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {\n  delegated_staking_activities(\n    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}\n  ) {\n    amount\n    delegator_address\n    event_index\n    event_type\n    pool_address\n    transaction_version\n  }\n}\n    `;\nexport const GetEvents = `\n    query getEvents($where_condition: events_bool_exp, $offset: Int, $limit: Int, $order_by: [events_order_by!]) {\n  events(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    account_address\n    creation_number\n    data\n    event_index\n    sequence_number\n    transaction_block_height\n    transaction_version\n    type\n    indexed_type\n  }\n}\n    `;\nexport const GetFungibleAssetActivities = `\n    query getFungibleAssetActivities($where_condition: fungible_asset_activities_bool_exp, $offset: Int, $limit: Int) {\n  fungible_asset_activities(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n  ) {\n    amount\n    asset_type\n    block_height\n    entry_function_id_str\n    event_index\n    gas_fee_payer_address\n    is_frozen\n    is_gas_fee\n    is_transaction_success\n    owner_address\n    storage_id\n    storage_refund_amount\n    token_standard\n    transaction_timestamp\n    transaction_version\n    type\n  }\n}\n    `;\nexport const GetFungibleAssetMetadata = `\n    query getFungibleAssetMetadata($where_condition: fungible_asset_metadata_bool_exp, $offset: Int, $limit: Int) {\n  fungible_asset_metadata(where: $where_condition, offset: $offset, limit: $limit) {\n    icon_uri\n    project_uri\n    supply_aggregator_table_handle_v1\n    supply_aggregator_table_key_v1\n    creator_address\n    asset_type\n    decimals\n    last_transaction_timestamp\n    last_transaction_version\n    name\n    symbol\n    token_standard\n    supply_v2\n    maximum_v2\n  }\n}\n    `;\nexport const GetNames = `\n    query getNames($offset: Int, $limit: Int, $where_condition: current_aptos_names_bool_exp, $order_by: [current_aptos_names_order_by!]) {\n  current_aptos_names(\n    limit: $limit\n    where: $where_condition\n    order_by: $order_by\n    offset: $offset\n  ) {\n    ...AnsTokenFragment\n  }\n}\n    ${AnsTokenFragmentFragmentDoc}`;\nexport const GetNumberOfDelegators = `\n    query getNumberOfDelegators($where_condition: num_active_delegator_per_pool_bool_exp, $order_by: [num_active_delegator_per_pool_order_by!]) {\n  num_active_delegator_per_pool(where: $where_condition, order_by: $order_by) {\n    num_active_delegator\n    pool_address\n  }\n}\n    `;\nexport const GetObjectData = `\n    query getObjectData($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {\n  current_objects(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    allow_ungated_transfer\n    state_key_hash\n    owner_address\n    object_address\n    last_transaction_version\n    last_guid_creation_num\n    is_deleted\n  }\n}\n    `;\nexport const GetProcessorStatus = `\n    query getProcessorStatus($where_condition: processor_status_bool_exp) {\n  processor_status(where: $where_condition) {\n    last_success_version\n    processor\n    last_updated\n  }\n}\n    `;\nexport const GetTableItemsData = `\n    query getTableItemsData($where_condition: table_items_bool_exp!, $offset: Int, $limit: Int, $order_by: [table_items_order_by!]) {\n  table_items(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    decoded_key\n    decoded_value\n    key\n    table_handle\n    transaction_version\n    write_set_change_index\n  }\n}\n    `;\nexport const GetTableItemsMetadata = `\n    query getTableItemsMetadata($where_condition: table_metadatas_bool_exp!, $offset: Int, $limit: Int, $order_by: [table_metadatas_order_by!]) {\n  table_metadatas(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    handle\n    key_type\n    value_type\n  }\n}\n    `;\nexport const GetTokenActivity = `\n    query getTokenActivity($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {\n  token_activities_v2(\n    where: $where_condition\n    order_by: $order_by\n    offset: $offset\n    limit: $limit\n  ) {\n    ...TokenActivitiesFields\n  }\n}\n    ${TokenActivitiesFieldsFragmentDoc}`;\nexport const GetCurrentTokenOwnership = `\n    query getCurrentTokenOwnership($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nexport const GetTokenData = `\n    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {\n  current_token_datas_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    collection_id\n    description\n    is_fungible_v2\n    largest_property_version_v1\n    last_transaction_timestamp\n    last_transaction_version\n    maximum\n    supply\n    token_data_id\n    token_name\n    token_properties\n    token_standard\n    token_uri\n    decimals\n    current_collection {\n      collection_id\n      collection_name\n      creator_address\n      current_supply\n      description\n      last_transaction_timestamp\n      last_transaction_version\n      max_supply\n      mutable_description\n      mutable_uri\n      table_handle_v1\n      token_standard\n      total_minted_v2\n      uri\n    }\n  }\n}\n    `;\n\nexport type SdkFunctionWrapper = <T>(\n  action: (requestHeaders?: Record<string, string>) => Promise<T>,\n  operationName: string,\n  operationType?: string,\n  variables?: any,\n) => Promise<T>;\n\nconst defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType, _variables) => action();\n\nexport function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {\n  return {\n    getAccountCoinsCount(\n      variables?: Types.GetAccountCoinsCountQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountCoinsCountQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountCoinsCountQuery>(GetAccountCoinsCount, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountCoinsCount\",\n        \"query\",\n        variables,\n      );\n    },\n    getAccountCoinsData(\n      variables: Types.GetAccountCoinsDataQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountCoinsDataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountCoinsDataQuery>(GetAccountCoinsData, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountCoinsData\",\n        \"query\",\n        variables,\n      );\n    },\n    getAccountCollectionsWithOwnedTokens(\n      variables: Types.GetAccountCollectionsWithOwnedTokensQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountCollectionsWithOwnedTokensQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountCollectionsWithOwnedTokensQuery>(\n            GetAccountCollectionsWithOwnedTokens,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders },\n          ),\n        \"getAccountCollectionsWithOwnedTokens\",\n        \"query\",\n        variables,\n      );\n    },\n    getAccountOwnedTokens(\n      variables: Types.GetAccountOwnedTokensQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountOwnedTokensQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountOwnedTokensQuery>(GetAccountOwnedTokens, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountOwnedTokens\",\n        \"query\",\n        variables,\n      );\n    },\n    getAccountOwnedTokensByTokenData(\n      variables: Types.GetAccountOwnedTokensByTokenDataQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountOwnedTokensByTokenDataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountOwnedTokensByTokenDataQuery>(GetAccountOwnedTokensByTokenData, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountOwnedTokensByTokenData\",\n        \"query\",\n        variables,\n      );\n    },\n    getAccountOwnedTokensFromCollection(\n      variables: Types.GetAccountOwnedTokensFromCollectionQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountOwnedTokensFromCollectionQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountOwnedTokensFromCollectionQuery>(\n            GetAccountOwnedTokensFromCollection,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders },\n          ),\n        \"getAccountOwnedTokensFromCollection\",\n        \"query\",\n        variables,\n      );\n    },\n    getAccountTokensCount(\n      variables?: Types.GetAccountTokensCountQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountTokensCountQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountTokensCountQuery>(GetAccountTokensCount, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountTokensCount\",\n        \"query\",\n        variables,\n      );\n    },\n    getAccountTransactionsCount(\n      variables?: Types.GetAccountTransactionsCountQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountTransactionsCountQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountTransactionsCountQuery>(GetAccountTransactionsCount, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountTransactionsCount\",\n        \"query\",\n        variables,\n      );\n    },\n    getChainTopUserTransactions(\n      variables?: Types.GetChainTopUserTransactionsQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetChainTopUserTransactionsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetChainTopUserTransactionsQuery>(GetChainTopUserTransactions, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getChainTopUserTransactions\",\n        \"query\",\n        variables,\n      );\n    },\n    getCollectionData(\n      variables: Types.GetCollectionDataQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetCollectionDataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetCollectionDataQuery>(GetCollectionData, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getCollectionData\",\n        \"query\",\n        variables,\n      );\n    },\n    getCurrentFungibleAssetBalances(\n      variables?: Types.GetCurrentFungibleAssetBalancesQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetCurrentFungibleAssetBalancesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetCurrentFungibleAssetBalancesQuery>(GetCurrentFungibleAssetBalances, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getCurrentFungibleAssetBalances\",\n        \"query\",\n        variables,\n      );\n    },\n    getDelegatedStakingActivities(\n      variables?: Types.GetDelegatedStakingActivitiesQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetDelegatedStakingActivitiesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetDelegatedStakingActivitiesQuery>(GetDelegatedStakingActivities, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getDelegatedStakingActivities\",\n        \"query\",\n        variables,\n      );\n    },\n    getEvents(\n      variables?: Types.GetEventsQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetEventsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetEventsQuery>(GetEvents, variables, { ...requestHeaders, ...wrappedRequestHeaders }),\n        \"getEvents\",\n        \"query\",\n        variables,\n      );\n    },\n    getFungibleAssetActivities(\n      variables?: Types.GetFungibleAssetActivitiesQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetFungibleAssetActivitiesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetFungibleAssetActivitiesQuery>(GetFungibleAssetActivities, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getFungibleAssetActivities\",\n        \"query\",\n        variables,\n      );\n    },\n    getFungibleAssetMetadata(\n      variables?: Types.GetFungibleAssetMetadataQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetFungibleAssetMetadataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetFungibleAssetMetadataQuery>(GetFungibleAssetMetadata, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getFungibleAssetMetadata\",\n        \"query\",\n        variables,\n      );\n    },\n    getNames(\n      variables?: Types.GetNamesQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetNamesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetNamesQuery>(GetNames, variables, { ...requestHeaders, ...wrappedRequestHeaders }),\n        \"getNames\",\n        \"query\",\n        variables,\n      );\n    },\n    getNumberOfDelegators(\n      variables?: Types.GetNumberOfDelegatorsQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetNumberOfDelegatorsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetNumberOfDelegatorsQuery>(GetNumberOfDelegators, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getNumberOfDelegators\",\n        \"query\",\n        variables,\n      );\n    },\n    getObjectData(\n      variables?: Types.GetObjectDataQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetObjectDataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetObjectDataQuery>(GetObjectData, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getObjectData\",\n        \"query\",\n        variables,\n      );\n    },\n    getProcessorStatus(\n      variables?: Types.GetProcessorStatusQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetProcessorStatusQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetProcessorStatusQuery>(GetProcessorStatus, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getProcessorStatus\",\n        \"query\",\n        variables,\n      );\n    },\n    getTableItemsData(\n      variables: Types.GetTableItemsDataQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetTableItemsDataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetTableItemsDataQuery>(GetTableItemsData, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getTableItemsData\",\n        \"query\",\n        variables,\n      );\n    },\n    getTableItemsMetadata(\n      variables: Types.GetTableItemsMetadataQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetTableItemsMetadataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetTableItemsMetadataQuery>(GetTableItemsMetadata, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getTableItemsMetadata\",\n        \"query\",\n        variables,\n      );\n    },\n    getTokenActivity(\n      variables: Types.GetTokenActivityQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetTokenActivityQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetTokenActivityQuery>(GetTokenActivity, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getTokenActivity\",\n        \"query\",\n        variables,\n      );\n    },\n    getCurrentTokenOwnership(\n      variables: Types.GetCurrentTokenOwnershipQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetCurrentTokenOwnershipQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetCurrentTokenOwnershipQuery>(GetCurrentTokenOwnership, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getCurrentTokenOwnership\",\n        \"query\",\n        variables,\n      );\n    },\n    getTokenData(\n      variables?: Types.GetTokenDataQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetTokenDataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetTokenDataQuery>(GetTokenData, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getTokenData\",\n        \"query\",\n        variables,\n      );\n    },\n  };\n}\nexport type Sdk = ReturnType<typeof getSdk>;\n","// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/account}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * account namespace and without having a dependency cycle error.\n */\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { getAptosFullNode, paginateWithCursor } from \"../client\";\nimport {\n  AccountData,\n  GetAccountCoinsDataResponse,\n  GetAccountCollectionsWithOwnedTokenResponse,\n  GetAccountOwnedTokensFromCollectionResponse,\n  GetAccountOwnedTokensQueryResponse,\n  GetObjectDataQueryResponse,\n  LedgerVersionArg,\n  MoveModuleBytecode,\n  MoveResource,\n  MoveStructId,\n  OrderByArg,\n  PaginationArgs,\n  TokenStandardArg,\n  TransactionResponse,\n  WhereArg,\n} from \"../types\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { Account } from \"../account\";\nimport { AnyPublicKey, Ed25519PublicKey, PrivateKey } from \"../core/crypto\";\nimport { queryIndexer } from \"./general\";\nimport {\n  GetAccountCoinsCountQuery,\n  GetAccountCoinsDataQuery,\n  GetAccountCollectionsWithOwnedTokensQuery,\n  GetObjectDataQuery,\n  GetAccountOwnedTokensFromCollectionQuery,\n  GetAccountOwnedTokensQuery,\n  GetAccountTokensCountQuery,\n  GetAccountTransactionsCountQuery,\n} from \"../types/generated/operations\";\nimport {\n  GetAccountCoinsCount,\n  GetAccountCoinsData,\n  GetAccountCollectionsWithOwnedTokens,\n  GetObjectData,\n  GetAccountOwnedTokens,\n  GetAccountOwnedTokensFromCollection,\n  GetAccountTokensCount,\n  GetAccountTransactionsCount,\n} from \"../types/generated/queries\";\nimport { memoizeAsync } from \"../utils/memoize\";\nimport { Secp256k1PrivateKey, AuthenticationKey, Ed25519PrivateKey, createObjectAddress } from \"../core\";\nimport { CurrentFungibleAssetBalancesBoolExp } from \"../types/generated/types\";\nimport { getTableItem } from \"./table\";\nimport { APTOS_COIN } from \"../utils\";\nimport { AptosApiError } from \"../errors\";\n\n/**\n * Retrieves account information for a specified account address.\n *\n * @param args - The arguments for retrieving account information.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.accountAddress - The address of the account to retrieve information for.\n */\nexport async function getInfo(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<AccountData> {\n  const { aptosConfig, accountAddress } = args;\n  const { data } = await getAptosFullNode<{}, AccountData>({\n    aptosConfig,\n    originMethod: \"getInfo\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}`,\n  });\n  return data;\n}\n\n/**\n * Retrieves the modules associated with a specified account address.\n *\n * @param args - The arguments for retrieving modules.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.accountAddress - The address of the account whose modules are to be retrieved.\n * @param args.options - Optional parameters for pagination and ledger version.\n * @param args.options.limit - The maximum number of modules to retrieve (default is 1000).\n * @param args.options.offset - The starting point for pagination.\n * @param args.options.ledgerVersion - The specific ledger version to query.\n */\nexport async function getModules(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & LedgerVersionArg;\n}): Promise<MoveModuleBytecode[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithCursor<{}, MoveModuleBytecode[]>({\n    aptosConfig,\n    originMethod: \"getModules\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/modules`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      start: options?.offset,\n      limit: options?.limit ?? 1000,\n    },\n  });\n}\n\n/**\n * Queries for a move module given an account address and module name.\n * This function can help you retrieve the module's ABI and other relevant information.\n *\n * @param args - The arguments for retrieving the module.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The account address in hex-encoded 32 byte format.\n * @param args.moduleName - The name of the module to retrieve.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - Specifies the ledger version of transactions. By default, the latest version will be used.\n * @returns The move module.\n */\nexport async function getModule(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  moduleName: string;\n  options?: LedgerVersionArg;\n}): Promise<MoveModuleBytecode> {\n  // We don't memoize the account module by ledger version, as it's not a common use case, this would be handled\n  // by the developer directly\n  if (args.options?.ledgerVersion !== undefined) {\n    return getModuleInner(args);\n  }\n\n  return memoizeAsync(\n    async () => getModuleInner(args),\n    `module-${args.accountAddress}-${args.moduleName}`,\n    1000 * 60 * 5, // 5 minutes\n  )();\n}\n\n/**\n * Retrieves the bytecode of a specified module from a given account address.\n *\n * @param args - The parameters for retrieving the module bytecode.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.accountAddress - The address of the account from which to retrieve the module.\n * @param args.moduleName - The name of the module to retrieve.\n * @param args.options - Optional parameters for specifying the ledger version.\n * @param args.options.ledgerVersion - The specific ledger version to query.\n */\nasync function getModuleInner(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  moduleName: string;\n  options?: LedgerVersionArg;\n}): Promise<MoveModuleBytecode> {\n  const { aptosConfig, accountAddress, moduleName, options } = args;\n\n  const { data } = await getAptosFullNode<{}, MoveModuleBytecode>({\n    aptosConfig,\n    originMethod: \"getModule\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/module/${moduleName}`,\n    params: { ledger_version: options?.ledgerVersion },\n  });\n  return data;\n}\n\n/**\n * Retrieves a list of transactions associated with a specific account address.\n * This function allows you to paginate through the transactions for better performance and usability.\n *\n * @param args - The arguments for retrieving transactions.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The account address for which to retrieve transactions.\n * @param args.options - Optional pagination parameters.\n * @param args.options.offset - The starting point for pagination.\n * @param args.options.limit - The maximum number of transactions to retrieve.\n */\nexport async function getTransactions(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs;\n}): Promise<TransactionResponse[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithCursor<{}, TransactionResponse[]>({\n    aptosConfig,\n    originMethod: \"getTransactions\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/transactions`,\n    params: { start: options?.offset, limit: options?.limit },\n  });\n}\n\n/**\n * Retrieves a list of resources associated with a specific account address.\n *\n * @param args - The arguments for retrieving resources.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account to fetch resources for.\n * @param args.options - Optional pagination and ledger version parameters.\n * @param args.options.offset - The starting point for pagination.\n * @param args.options.limit - The maximum number of resources to retrieve (default is 999).\n * @param args.options.ledgerVersion - The specific ledger version to query.\n */\nexport async function getResources(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & LedgerVersionArg;\n}): Promise<MoveResource[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithCursor<{}, MoveResource[]>({\n    aptosConfig,\n    originMethod: \"getResources\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/resources`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      start: options?.offset,\n      limit: options?.limit ?? 999,\n    },\n  });\n}\n\n/**\n * Retrieves a specific resource of a given type for the specified account address.\n *\n * @param args - The arguments for retrieving the resource.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account from which to retrieve the resource.\n * @param args.resourceType - The type of the resource to retrieve, specified as a MoveStructId.\n * @param args.options - Optional parameters for specifying the ledger version.\n */\nexport async function getResource<T extends {}>(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  resourceType: MoveStructId;\n  options?: LedgerVersionArg;\n}): Promise<T> {\n  const { aptosConfig, accountAddress, resourceType, options } = args;\n  const { data } = await getAptosFullNode<{}, MoveResource>({\n    aptosConfig,\n    originMethod: \"getResource\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/resource/${resourceType}`,\n    params: { ledger_version: options?.ledgerVersion },\n  });\n  return data.data as T;\n}\n\n/**\n * Retrieves the original account address associated with a given authentication key, which is useful for handling key rotations.\n *\n * @param args - The arguments for the lookup.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.authenticationKey - The authentication key for which to look up the original address.\n * @param args.options - Optional parameters for specifying the ledger version.\n * @returns The original account address or the provided authentication key address if not found.\n * @throws Throws an error if the lookup fails for reasons other than the address not being found.\n */\nexport async function lookupOriginalAccountAddress(args: {\n  aptosConfig: AptosConfig;\n  authenticationKey: AccountAddressInput;\n  options?: LedgerVersionArg;\n}): Promise<AccountAddress> {\n  const { aptosConfig, authenticationKey, options } = args;\n  type OriginatingAddress = {\n    address_map: { handle: string };\n  };\n  const resource = await getResource<OriginatingAddress>({\n    aptosConfig,\n    accountAddress: \"0x1\",\n    resourceType: \"0x1::account::OriginatingAddress\",\n    options,\n  });\n\n  const {\n    address_map: { handle },\n  } = resource;\n\n  const authKeyAddress = AccountAddress.from(authenticationKey);\n\n  // If the address is not found in the address map, which means its not rotated\n  // then return the address as is\n  try {\n    const originalAddress = await getTableItem<string>({\n      aptosConfig,\n      handle,\n      data: {\n        key: authKeyAddress.toString(),\n        key_type: \"address\",\n        value_type: \"address\",\n      },\n      options,\n    });\n\n    return AccountAddress.from(originalAddress);\n  } catch (err) {\n    if (err instanceof AptosApiError && err.data.error_code === \"table_item_not_found\") {\n      return authKeyAddress;\n    }\n\n    throw err;\n  }\n}\n\n/**\n * Retrieves the count of tokens owned by a specific account address.\n *\n * @param args - The arguments for retrieving the account tokens count.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.accountAddress - The address of the account for which to count the tokens.\n * @returns The count of tokens owned by the specified account.\n */\nexport async function getAccountTokensCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string }; amount: { _gt: number } } = {\n    owner_address: { _eq: address },\n    amount: { _gt: 0 },\n  };\n\n  const graphqlQuery = {\n    query: GetAccountTokensCount,\n    variables: { where_condition: whereCondition },\n  };\n\n  const data = await queryIndexer<GetAccountTokensCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTokensCount\",\n  });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data.current_token_ownerships_v2_aggregate.aggregate\n    ? data.current_token_ownerships_v2_aggregate.aggregate.count\n    : 0;\n}\n\n/**\n * Retrieves the tokens owned by a specified account address.\n *\n * @param args - The arguments for retrieving the account's tokens.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The address of the account whose tokens are being queried.\n * @param args.options - Optional parameters for filtering and pagination.\n * @param args.options.tokenStandard - The specific token standard to filter the results.\n * @param args.options.offset - The number of records to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of records to return.\n * @param args.options.orderBy - The criteria for ordering the results.\n * @returns A promise that resolves to the current token ownerships of the specified account.\n */\nexport async function getAccountOwnedTokens(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensQueryResponse[0]>;\n}): Promise<GetAccountOwnedTokensQueryResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string }; amount: { _gt: number }; token_standard?: { _eq: string } } =\n    {\n      owner_address: { _eq: address },\n      amount: { _gt: 0 },\n    };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountOwnedTokensQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokens\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\n/**\n * Retrieves the tokens owned by a specific account from a particular collection address.\n *\n * @param args - The parameters required to fetch the owned tokens.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.accountAddress - The address of the account whose tokens are being queried.\n * @param args.collectionAddress - The address of the collection from which tokens are being retrieved.\n * @param args.options - Optional parameters for filtering and pagination, including token standard, pagination arguments, and\n * order by options.\n */\nexport async function getAccountOwnedTokensFromCollectionAddress(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  collectionAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensFromCollectionResponse[0]>;\n}): Promise<GetAccountOwnedTokensFromCollectionResponse> {\n  const { aptosConfig, accountAddress, collectionAddress, options } = args;\n  const ownerAddress = AccountAddress.from(accountAddress).toStringLong();\n  const collAddress = AccountAddress.from(collectionAddress).toStringLong();\n\n  const whereCondition: {\n    owner_address: { _eq: string };\n    current_token_data: { collection_id: { _eq: string } };\n    amount: { _gt: number };\n    token_standard?: { _eq: string };\n  } = {\n    owner_address: { _eq: ownerAddress },\n    current_token_data: { collection_id: { _eq: collAddress } },\n    amount: { _gt: 0 },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountOwnedTokensFromCollection,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountOwnedTokensFromCollectionQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokensFromCollectionAddress\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\n/**\n * Retrieves the collections owned by a specified account along with the tokens in those collections.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The address of the account whose collections are being queried.\n * @param args.options - Optional parameters for filtering and pagination.\n * @param args.options.tokenStandard - An optional token standard to filter the collections.\n * @param args.options.offset - An optional offset for pagination.\n * @param args.options.limit - An optional limit for the number of results returned.\n * @param args.options.orderBy - An optional parameter to specify the order of the results.\n */\nexport async function getAccountCollectionsWithOwnedTokens(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountCollectionsWithOwnedTokenResponse[0]>;\n}): Promise<GetAccountCollectionsWithOwnedTokenResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: {\n    owner_address: { _eq: string };\n    current_collection?: { token_standard: { _eq: string } };\n  } = {\n    owner_address: { _eq: address },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.current_collection = {\n      token_standard: { _eq: options?.tokenStandard },\n    };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountCollectionsWithOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountCollectionsWithOwnedTokensQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCollectionsWithOwnedTokens\",\n  });\n\n  return data.current_collection_ownership_v2_view;\n}\n\n/**\n * Retrieves the count of transactions associated with a specified account.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account for which to retrieve the transaction count.\n * @returns The number of transactions associated with the specified account.\n */\nexport async function getAccountTransactionsCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const graphqlQuery = {\n    query: GetAccountTransactionsCount,\n    variables: { address },\n  };\n\n  const data = await queryIndexer<GetAccountTransactionsCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTransactionsCount\",\n  });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data.account_transactions_aggregate.aggregate ? data.account_transactions_aggregate.aggregate.count : 0;\n}\n\n/**\n * Retrieves the amount of a specific coin held by an account.\n *\n * @param args - The parameters for the request.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.accountAddress - The address of the account to query.\n * @param args.coinType - Optional; the type of coin to check the amount for.\n * @param args.faMetadataAddress - Optional; the address of the fungible asset metadata.\n * @returns The amount of the specified coin held by the account, or 0 if none is found.\n * @throws Error if neither coinType nor faMetadataAddress is provided.\n */\nexport async function getAccountCoinAmount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  coinType?: MoveStructId;\n  faMetadataAddress?: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress, coinType, faMetadataAddress } = args;\n\n  let coinAssetType: string | undefined = coinType;\n  let faAddress: string;\n\n  if (coinType !== undefined && faMetadataAddress !== undefined) {\n    faAddress = AccountAddress.from(faMetadataAddress).toStringLong();\n  } else if (coinType !== undefined && faMetadataAddress === undefined) {\n    // TODO Move to a separate function as defined in the AIP for coin migration\n    if (coinType === APTOS_COIN) {\n      faAddress = AccountAddress.A.toStringLong();\n    } else {\n      faAddress = createObjectAddress(AccountAddress.A, coinType).toStringLong();\n    }\n  } else if (coinType === undefined && faMetadataAddress !== undefined) {\n    const addr = AccountAddress.from(faMetadataAddress);\n    faAddress = addr.toStringLong();\n    if (addr === AccountAddress.A) {\n      coinAssetType = APTOS_COIN;\n    }\n    // The paired CoinType should be populated outside of this function in another\n    // async call. We cannot do this internally due to dependency cycles issue.\n  } else {\n    throw new Error(\"Either coinType, fungibleAssetAddress, or both must be provided\");\n  }\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  // Search by fungible asset address, unless it has a coin it migrated from\n  let where: any = { asset_type: { _eq: faAddress } };\n  if (coinAssetType !== undefined) {\n    where = { asset_type: { _in: [coinAssetType, faAddress] } };\n  }\n\n  const data = await getAccountCoinsData({\n    aptosConfig,\n    accountAddress: address,\n    options: {\n      where,\n    },\n  });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data[0] ? data[0].amount : 0;\n}\n\n/**\n * Retrieves the current fungible asset balances for a specified account.\n *\n * @param args - The arguments for retrieving account coins data.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.accountAddress - The address of the account for which to retrieve coin data.\n * @param args.options - Optional parameters for pagination and filtering the results.\n * @param args.options.offset - The number of items to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of items to return.\n * @param args.options.orderBy - The criteria for ordering the results.\n * @param args.options.where - Conditions to filter the results based on the current fungible asset balances.\n */\nexport async function getAccountCoinsData(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetAccountCoinsDataResponse[0]> & WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n}): Promise<GetAccountCoinsDataResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string } } = {\n    ...options?.where,\n    owner_address: { _eq: address },\n  };\n\n  const graphqlQuery = {\n    query: GetAccountCoinsData,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountCoinsDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsData\",\n  });\n\n  return data.current_fungible_asset_balances;\n}\n\n/**\n * Retrieves the count of fungible asset coins held by a specified account.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.accountAddress - The address of the account for which to retrieve the coin count.\n * @throws Error if the count of account coins cannot be retrieved.\n */\nexport async function getAccountCoinsCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const graphqlQuery = {\n    query: GetAccountCoinsCount,\n    variables: { address },\n  };\n\n  const data = await queryIndexer<GetAccountCoinsCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsCount\",\n  });\n\n  if (!data.current_fungible_asset_balances_aggregate.aggregate) {\n    throw Error(\"Failed to get the count of account coins\");\n  }\n\n  return data.current_fungible_asset_balances_aggregate.aggregate.count;\n}\n\n/**\n * Retrieves the objects owned by a specified account.\n *\n * @param args - The parameters for the request.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The address of the account whose owned objects are to be retrieved.\n * @param args.options - Optional parameters for pagination and ordering of the results.\n * @param args.options.offset - The number of items to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of items to return.\n * @param args.options.orderBy - The criteria to order the results by.\n * @returns A promise that resolves to the current objects owned by the specified account.\n */\nexport async function getAccountOwnedObjects(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetObjectDataQueryResponse[0]>;\n}): Promise<GetObjectDataQueryResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string } } = {\n    owner_address: { _eq: address },\n  };\n  const graphqlQuery = {\n    query: GetObjectData,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n  const data = await queryIndexer<GetObjectDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedObjects\",\n  });\n\n  return data.current_objects;\n}\n\n/**\n * Derives an account from the provided private key and Aptos configuration.\n * This function helps in obtaining the account details associated with a given private key,\n * considering both unified and legacy authentication schemes.\n *\n * NOTE: There is a potential issue once the unified single signer scheme is adopted by the community.\n * Because one could create two accounts with the same private key with this new authenticator type,\n * we’ll need to determine the order in which we look up the accounts: first unified scheme and then legacy scheme,\n * or first legacy scheme and then unified scheme.\n *\n * @param args - The arguments for deriving the account.\n * @param args.aptosConfig - The Aptos configuration used for account lookup.\n * @param args.privateKey - The private key used to derive the account.\n * @throws Error if the account cannot be derived from the private key.\n */\nexport async function deriveAccountFromPrivateKey(args: {\n  aptosConfig: AptosConfig;\n  privateKey: PrivateKey;\n}): Promise<Account> {\n  const { aptosConfig, privateKey } = args;\n  const publicKey = new AnyPublicKey(privateKey.publicKey());\n\n  if (privateKey instanceof Secp256k1PrivateKey) {\n    // private key is secp256k1, therefore we know it for sure uses a single signer key\n    const authKey = AuthenticationKey.fromPublicKey({ publicKey });\n    const address = authKey.derivedAddress();\n    return Account.fromPrivateKey({ privateKey, address });\n  }\n\n  if (privateKey instanceof Ed25519PrivateKey) {\n    // lookup single sender ed25519\n    const singleSenderTransactionAuthenticatorAuthKey = AuthenticationKey.fromPublicKey({\n      publicKey,\n    });\n    const isSingleSenderTransactionAuthenticator = await isAccountExist({\n      authKey: singleSenderTransactionAuthenticatorAuthKey,\n      aptosConfig,\n    });\n    if (isSingleSenderTransactionAuthenticator) {\n      const address = singleSenderTransactionAuthenticatorAuthKey.derivedAddress();\n      return Account.fromPrivateKey({ privateKey, address, legacy: false });\n    }\n    // lookup legacy ed25519\n    const legacyAuthKey = AuthenticationKey.fromPublicKey({\n      publicKey: publicKey.publicKey as Ed25519PublicKey,\n    });\n    const isLegacyEd25519 = await isAccountExist({ authKey: legacyAuthKey, aptosConfig });\n    if (isLegacyEd25519) {\n      const address = legacyAuthKey.derivedAddress();\n      return Account.fromPrivateKey({ privateKey, address, legacy: true });\n    }\n  }\n  // if we are here, it means we couldn't find an address with an\n  // auth key that matches the provided private key\n  throw new Error(`Can't derive account from private key ${privateKey}`);\n}\n\n/**\n * Checks if an account exists by verifying its information against the Aptos blockchain.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.authKey - The authentication key used to derive the account address.\n * @returns A promise that resolves to a boolean indicating whether the account exists.\n *\n * @throws Throws an Error if there is an issue while looking for account information.\n */\nexport async function isAccountExist(args: { aptosConfig: AptosConfig; authKey: AuthenticationKey }): Promise<boolean> {\n  const { aptosConfig, authKey } = args;\n  const accountAddress = await lookupOriginalAccountAddress({\n    aptosConfig,\n    authenticationKey: authKey.derivedAddress(),\n  });\n\n  try {\n    await getInfo({\n      aptosConfig,\n      accountAddress,\n    });\n    return true;\n  } catch (error: any) {\n    // account not found\n    if (error.status === 404) {\n      return false;\n    }\n    throw new Error(`Error while looking for an account info ${accountAddress.toString()}`);\n  }\n}\n","// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Account as AccountModule } from \"../account\";\nimport { AccountAddress, PrivateKey, AccountAddressInput, createObjectAddress } from \"../core\";\nimport {\n  AccountData,\n  AnyNumber,\n  GetAccountCoinsDataResponse,\n  GetAccountCollectionsWithOwnedTokenResponse,\n  GetAccountOwnedTokensFromCollectionResponse,\n  GetAccountOwnedTokensQueryResponse,\n  GetObjectDataQueryResponse,\n  LedgerVersionArg,\n  MoveModuleBytecode,\n  MoveResource,\n  MoveStructId,\n  MoveValue,\n  OrderByArg,\n  PaginationArgs,\n  TokenStandardArg,\n  TransactionResponse,\n  WhereArg,\n} from \"../types\";\nimport {\n  deriveAccountFromPrivateKey,\n  getAccountCoinsCount,\n  getAccountCoinsData,\n  getAccountCollectionsWithOwnedTokens,\n  getAccountOwnedObjects,\n  getAccountOwnedTokens,\n  getAccountOwnedTokensFromCollectionAddress,\n  getAccountTokensCount,\n  getAccountTransactionsCount,\n  getInfo,\n  getModule,\n  getModules,\n  getResource,\n  getResources,\n  getTransactions,\n  lookupOriginalAccountAddress,\n} from \"../internal/account\";\nimport { APTOS_COIN, APTOS_FA, ProcessorType } from \"../utils/const\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { waitForIndexerOnVersion } from \"./utils\";\nimport { CurrentFungibleAssetBalancesBoolExp } from \"../types/generated/types\";\nimport { view } from \"../internal/view\";\nimport { isEncodedStruct, parseEncodedStruct } from \"../utils\";\nimport { memoizeAsync } from \"../utils/memoize\";\n\n/**\n * A class to query all `Account` related queries on Aptos.\n */\nexport class Account {\n  /**\n   * Creates an instance of the Aptos client with the provided configuration.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Initialize the Aptos client with testnet configuration\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // specify your own network if needed\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Queries the current state for an Aptos account given its account address.\n   *\n   * @param args - The arguments for retrieving account information.\n   * @param args.accountAddress - The Aptos account address to query.\n   * @returns The account data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     // Retrieve account information for a specific address\n   *     const accountInfo = await aptos.getAccountInfo({ accountAddress: \"0x1\" }); // replace with a real account address\n   *     console.log(accountInfo);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async getAccountInfo(args: { accountAddress: AccountAddressInput }): Promise<AccountData> {\n    return getInfo({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for all modules in an account given an account address.\n   * This function may call the API multiple times to auto paginate through results.\n   *\n   * @param args.accountAddress - The Aptos account address to query modules for.\n   * @param args.options.offset - The number of modules to start returning results from.\n   * @param args.options.limit - The maximum number of results to return.\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it retrieves the latest version.\n   *\n   * @returns - The account modules associated with the specified address.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching account modules for a specific account\n   *   const accountModules = await aptos.getAccountModules({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       offset: 0, // starting from the first module\n   *       limit: 10, // limiting to 10 modules\n   *     },\n   *   });\n   *\n   *   console.log(accountModules);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async getAccountModules(args: {\n    accountAddress: AccountAddressInput;\n    options?: PaginationArgs & LedgerVersionArg;\n  }): Promise<MoveModuleBytecode[]> {\n    return getModules({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for a specific account module given an account address and module name.\n   *\n   * @param args.accountAddress - The Aptos account address.\n   * @param args.moduleName - The name of the module.\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n   *\n   * @returns The account module associated with the specified account address and module name.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the account module for a specific account address and module name\n   *   const module = await aptos.getAccountModule({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     moduleName: \"MyModule\" // specify the module name\n   *   });\n   *\n   *   console.log(module);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async getAccountModule(args: {\n    accountAddress: AccountAddressInput;\n    moduleName: string;\n    options?: LedgerVersionArg;\n  }): Promise<MoveModuleBytecode> {\n    return getModule({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries account transactions given an account address.\n   * This function may call the API multiple times to auto paginate and retrieve all account transactions.\n   *\n   * @param args.accountAddress - The Aptos account address to query transactions for.\n   * @param args.options - Optional pagination arguments.\n   * @param args.options.offset - The number of transactions to start returning results from.\n   * @param args.options.limit - The maximum number of results to return.\n   *\n   * @returns The account transactions.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetch transactions for a specific account\n   *   const transactions = await aptos.getAccountTransactions({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       offset: 0, // starting from the first transaction\n   *       limit: 10, // limiting to 10 transactions\n   *     },\n   *   });\n   *\n   *   console.log(transactions);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async getAccountTransactions(args: {\n    accountAddress: AccountAddressInput;\n    options?: PaginationArgs;\n  }): Promise<TransactionResponse[]> {\n    return getTransactions({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries all account resources given an account address.\n   * This function may call the API multiple times to auto paginate through results.\n   *\n   * @param args.accountAddress - The Aptos account address to query resources for.\n   * @param args.options.offset - The number of resources to start returning results from.\n   * @param args.options.limit - The maximum number of results to return.\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n   * @returns Account resources.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching account resources for a specific account address\n   *   const resources = await aptos.getAccountResources({ accountAddress: \"0x1\" }); // replace with a real account address\n   *   console.log(resources);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async getAccountResources(args: {\n    accountAddress: AccountAddressInput;\n    options?: PaginationArgs & LedgerVersionArg;\n  }): Promise<MoveResource[]> {\n    return getResources({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries a specific account resource given an account address and resource type.\n   *\n   * @template T - The typed output of the resource.\n   * @param args.accountAddress - The Aptos account address to query.\n   * @param args.resourceType - The string representation of an on-chain Move struct type, e.g., \"0x1::aptos_coin::AptosCoin\".\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n   * @returns The account resource of the specified type.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the account resource for a specific account address and resource type\n   *   const resource = await aptos.getAccountResource({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     resourceType: \"0x1::aptos_coin::AptosCoin\"\n   *   });\n   *\n   *   console.log(resource);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async getAccountResource<T extends {} = any>(args: {\n    accountAddress: AccountAddressInput;\n    resourceType: MoveStructId;\n    options?: LedgerVersionArg;\n  }): Promise<T> {\n    return getResource<T>({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Looks up the account address for a given authentication key, handling both rotated and non-rotated keys.\n   *\n   * @param args.authenticationKey - The authentication key for which to look up the account address.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n   * @returns Promise<AccountAddress> - The account address associated with the authentication key.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Look up the original account address for a given authentication key\n   *   const accountAddress = await aptos.lookupOriginalAccountAddress({\n   *     authenticationKey: \"0x1\", // replace with a real authentication key\n   *   });\n   *\n   *   console.log(\"Original Account Address:\", accountAddress);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async lookupOriginalAccountAddress(args: {\n    authenticationKey: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: LedgerVersionArg;\n  }): Promise<AccountAddress> {\n    return lookupOriginalAccountAddress({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries the current count of tokens owned by a specified account.\n   *\n   * @param args - The parameters for the query.\n   * @param args.accountAddress - The account address to query the token count for.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @returns The current count of tokens owned by the account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the count of tokens owned by the account\n   *   const tokensCount = await aptos.getAccountTokensCount({ accountAddress: \"0x1\" }); // replace with a real account address\n   *   console.log(`Tokens Count: ${tokensCount}`);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async getAccountTokensCount(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.ACCOUNT_TRANSACTION_PROCESSOR,\n    });\n    return getAccountTokensCount({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries the tokens currently owned by a specified account, including NFTs and fungible tokens.\n   * If desired, you can filter the results by a specific token standard.\n   *\n   * @param args.accountAddress The account address for which to retrieve owned tokens.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @param args.options.tokenStandard Optional filter for the NFT standard to query for.\n   * @param args.options.offset Optional number to start returning results from.\n   * @param args.options.limit Optional number of results to return.\n   * @param args.options.orderBy Optional order to sort the tokens by.\n   * @returns An array of tokens with their respective data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the tokens owned by a specific account\n   *   const accountOwnedTokens = await aptos.getAccountOwnedTokens({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       limit: 10, // specify how many tokens to return\n   *       orderBy: \"created_at\", // specify the order of the results\n   *     },\n   *   });\n   *\n   *   console.log(accountOwnedTokens);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async getAccountOwnedTokens(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensQueryResponse[0]>;\n  }): Promise<GetAccountOwnedTokensQueryResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getAccountOwnedTokens({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries all current tokens of a specific collection that an account owns by the collection address.\n   * This query returns all tokens (v1 and v2 standards) an account owns, including NFTs, fungible, soulbound, etc.\n   * If you want to get only the token from a specific standard, you can pass an optional tokenStandard parameter.\n   *\n   * @param args.accountAddress - The account address we want to get the tokens for.\n   * @param args.collectionAddress - The address of the collection being queried.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to, before querying.\n   * @param args.options.tokenStandard - The NFT standard to query for.\n   * @param args.options.offset - The number token to start returning results from.\n   * @param args.options.limit - The number of results to return.\n   * @param args.options.orderBy - The order to sort the tokens by.\n   * @returns Tokens array with the token data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get tokens owned by a specific account in a specific collection\n   *   const accountOwnedTokens = await aptos.getAccountOwnedTokensFromCollectionAddress({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     collectionAddress: \"0x2\", // replace with a real collection address\n   *   });\n   *\n   *   console.log(accountOwnedTokens);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async getAccountOwnedTokensFromCollectionAddress(args: {\n    accountAddress: AccountAddressInput;\n    collectionAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensFromCollectionResponse[0]>;\n  }): Promise<GetAccountOwnedTokensFromCollectionResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getAccountOwnedTokensFromCollectionAddress({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries for all collections that an account currently has tokens for, including NFTs, fungible tokens, and soulbound tokens.\n   * If you want to filter by a specific token standard, you can pass an optional tokenStandard parameter.\n   *\n   * @param args.accountAddress - The account address we want to get the collections for.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options.tokenStandard - The NFT standard to query for.\n   * @param args.options.offset - The number of the collection to start returning results from.\n   * @param args.options.limit - The number of results to return.\n   * @param args.options.orderBy - The order to sort the tokens by.\n   * @returns Collections array with the collections data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get account collections with owned tokens for a specific account\n   *   const accountCollectionsWithOwnedTokens = await aptos.getAccountCollectionsWithOwnedTokens({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       tokenStandard: \"NFT\", // specify the token standard if needed\n   *       limit: 10, // specify the number of results to return\n   *     },\n   *   });\n   *\n   *   console.log(accountCollectionsWithOwnedTokens);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async getAccountCollectionsWithOwnedTokens(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountCollectionsWithOwnedTokenResponse[0]>;\n  }): Promise<GetAccountCollectionsWithOwnedTokenResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getAccountCollectionsWithOwnedTokens({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries the current count of transactions submitted by an account.\n   *\n   * @param args - The parameters for the query.\n   * @param args.accountAddress - The account address we want to get the total count for.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @returns Current count of transactions made by an account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the count of transactions for a specific account\n   *   const accountTransactionsCount = await aptos.getAccountTransactionsCount({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     minimumLedgerVersion: 1, // specify your own minimum ledger version if needed\n   *   });\n   *\n   *   console.log(accountTransactionsCount);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async getAccountTransactionsCount(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.ACCOUNT_TRANSACTION_PROCESSOR,\n    });\n    return getAccountTransactionsCount({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Retrieves the coins data for a specified account.\n   *\n   * @param args.accountAddress - The account address for which to retrieve the coin's data.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options.offset - Optional. The number of coins to start returning results from.\n   * @param args.options.limit - Optional. The number of results to return.\n   * @param args.options.orderBy - Optional. The order to sort the coins by.\n   * @param args.options.where - Optional. Filter the results by specific criteria.\n   * @returns An array containing the coins data for the specified account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching coins data for a specific account\n   *   const accountCoinsData = await aptos.getAccountCoinsData({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       limit: 10, // specify the number of results to return\n   *       orderBy: { asset_type: \"asc\" }, // specify the order of results\n   *     },\n   *   });\n   *\n   *   console.log(accountCoinsData);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async getAccountCoinsData(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs &\n      OrderByArg<GetAccountCoinsDataResponse[0]> &\n      WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n  }): Promise<GetAccountCoinsDataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    return getAccountCoinsData({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Retrieves the current count of an account's coins aggregated across all types.\n   *\n   * @param args The parameters for the account coins count query.\n   * @param args.accountAddress The account address we want to get the total count for.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @returns The current count of the aggregated coins for the specified account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Getting the account coins count for a specific account\n   *   const accountCoinsCount = await aptos.getAccountCoinsCount({ accountAddress: \"0x1\" }); // replace with a real account address\n   *   console.log(\"Account Coins Count:\", accountCoinsCount);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async getAccountCoinsCount(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    return getAccountCoinsCount({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieves the current amount of APT for a specified account.\n   *\n   * @param args The arguments for the account query.\n   * @param args.accountAddress The account address for which to retrieve the APT amount.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @returns The current amount of APT for the specified account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the APT amount for a specific account\n   *   const accountAPTAmount = await aptos.getAccountAPTAmount({ accountAddress: \"0x1\" }); // replace with a real account address\n   *   console.log(\"Account APT Amount:\", accountAPTAmount);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async getAccountAPTAmount(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    return this.getAccountCoinAmount({ coinType: APTOS_COIN, faMetadataAddress: APTOS_FA, ...args });\n  }\n\n  /**\n   * Queries the current amount of a specified coin held by an account.\n   *\n   * @param args The parameters for querying the account's coin amount.\n   * @param args.accountAddress The account address to query for the coin amount.\n   * @param args.coinType The coin type to query. Note: If not provided, it may be automatically populated if `faMetadataAddress`\n   * is specified.\n   * @param args.faMetadataAddress The fungible asset metadata address to query. Note: If not provided, it may be automatically\n   * populated if `coinType` is specified.\n   * @param args.minimumLedgerVersion Not used anymore, here for backward compatibility\n   * see https://github.com/aptos-labs/aptos-ts-sdk/pull/519, will be removed in the near future.\n   * Optional ledger version to sync up to before querying.\n   * @returns The current amount of the specified coin held by the account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Query the account's coin amount for a specific coin type\n   *   const accountCoinAmount = await aptos.getAccountCoinAmount({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     coinType: \"0x1::aptos_coin::AptosCoin\" // specify the coin type\n   *   });\n   *\n   *   console.log(`Account coin amount: ${accountCoinAmount}`);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async getAccountCoinAmount(args: {\n    accountAddress: AccountAddressInput;\n    coinType?: MoveStructId;\n    faMetadataAddress?: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    const { accountAddress, coinType, faMetadataAddress, minimumLedgerVersion } = args;\n\n    if (minimumLedgerVersion) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `minimumLedgerVersion is not used anymore, here for backward \n        compatibility see https://github.com/aptos-labs/aptos-ts-sdk/pull/519, \n        will be removed in the near future`,\n      );\n    }\n    // Attempt to populate the CoinType field if the FA address is provided.\n    // We cannot do this internally due to dependency cycles issue.\n    let coinAssetType: MoveStructId | undefined = coinType;\n    if (coinType === undefined && faMetadataAddress !== undefined) {\n      coinAssetType = await memoizeAsync(\n        async () => {\n          try {\n            const pairedCoinTypeStruct = (\n              await view({\n                aptosConfig: this.config,\n                payload: { function: \"0x1::coin::paired_coin\", functionArguments: [faMetadataAddress] },\n              })\n            ).at(0) as { vec: MoveValue[] };\n\n            // Check if the Option has a value, and if so, parse the struct\n            if (pairedCoinTypeStruct.vec.length > 0 && isEncodedStruct(pairedCoinTypeStruct.vec[0])) {\n              return parseEncodedStruct(pairedCoinTypeStruct.vec[0]) as MoveStructId;\n            }\n          } catch (error) {\n            /* No paired coin type found */\n          }\n          return undefined;\n        },\n        `coin-mapping-${faMetadataAddress.toString()}`,\n        1000 * 60 * 5, // 5 minutes\n      )();\n    }\n\n    let faAddress: string;\n\n    if (coinType !== undefined && faMetadataAddress !== undefined) {\n      faAddress = AccountAddress.from(faMetadataAddress).toStringLong();\n    } else if (coinType !== undefined && faMetadataAddress === undefined) {\n      // TODO Move to a separate function as defined in the AIP for coin migration\n      if (coinType === APTOS_COIN) {\n        faAddress = AccountAddress.A.toStringLong();\n      } else {\n        faAddress = createObjectAddress(AccountAddress.A, coinType).toStringLong();\n      }\n    } else if (coinType === undefined && faMetadataAddress !== undefined) {\n      const addr = AccountAddress.from(faMetadataAddress);\n      faAddress = addr.toStringLong();\n      if (addr === AccountAddress.A) {\n        coinAssetType = APTOS_COIN;\n      }\n      // The paired CoinType should be populated outside of this function in another\n      // async call. We cannot do this internally due to dependency cycles issue.\n    } else {\n      throw new Error(\"Either coinType, faMetadataAddress, or both must be provided\");\n    }\n\n    // When there is a coin mapping, use that first, otherwise use the fungible asset address\n    // TODO: This function's signature at the top, returns number, but it could be greater than can be represented\n    if (coinAssetType !== undefined) {\n      const [balanceStr] = await view<[string]>({\n        aptosConfig: this.config,\n        payload: {\n          function: \"0x1::coin::balance\",\n          typeArguments: [coinAssetType],\n          functionArguments: [accountAddress],\n        },\n      });\n      return parseInt(balanceStr, 10);\n    }\n    const [balanceStr] = await view<[string]>({\n      aptosConfig: this.config,\n      payload: {\n        function: \"0x1::primary_fungible_store::balance\",\n        typeArguments: [\"0x1::object::ObjectCore\"],\n        functionArguments: [accountAddress, faAddress],\n      },\n    });\n    return parseInt(balanceStr, 10);\n  }\n\n  /**\n   * Queries an account's owned objects.\n   *\n   * @param args.accountAddress The account address we want to get the objects for.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @param args.options.offset The starting position to start returning results from.\n   * @param args.options.limit The number of results to return.\n   * @param args.options.orderBy The order to sort the objects by.\n   * @returns Objects array with the object data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the objects owned by the specified account\n   *   const accountOwnedObjects = await aptos.getAccountOwnedObjects({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     minimumLedgerVersion: 1, // optional, specify if needed\n   *     options: {\n   *       offset: 0, // optional, specify if needed\n   *       limit: 10, // optional, specify if needed\n   *       orderBy: \"created_at\", // optional, specify if needed\n   *     },\n   *   });\n   *\n   *   console.log(accountOwnedObjects);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async getAccountOwnedObjects(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & OrderByArg<GetObjectDataQueryResponse[0]>;\n  }): Promise<GetObjectDataQueryResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.DEFAULT,\n    });\n    return getAccountOwnedObjects({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Derives an account by providing a private key. This function resolves the provided private key type and derives the public\n   * key from it.\n   *\n   * If the privateKey is a Secp256k1 type, it derives the account using the derived public key and auth key using the SingleKey\n   * scheme locally.\n   * If the privateKey is an ED25519 type, it looks up the authentication key on chain to determine whether it is a Legacy ED25519\n   * key or a Unified ED25519 key, and then derives the account based on that.\n   *\n   * @param args - The arguments for deriving the account.\n   * @param args.privateKey - An account private key.\n   * @returns The derived Account type.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Ed25519PrivateKey } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     // Deriving an account from a private key\n   *     const account = await aptos.deriveAccountFromPrivateKey({\n   *         privateKey: new Ed25519PrivateKey(\"0x123\") // replace with a real private key\n   *     });\n   *\n   *     console.log(account);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  async deriveAccountFromPrivateKey(args: { privateKey: PrivateKey }): Promise<AccountModule> {\n    return deriveAccountFromPrivateKey({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport aptosClient from \"@aptos-labs/aptos-client\";\nimport { AptosSettings, ClientConfig, Client, FullNodeConfig, IndexerConfig, FaucetConfig } from \"../types\";\nimport {\n  NetworkToNodeAPI,\n  NetworkToFaucetAPI,\n  NetworkToIndexerAPI,\n  Network,\n  NetworkToPepperAPI,\n  NetworkToProverAPI,\n} from \"../utils/apiEndpoints\";\nimport { AptosApiType } from \"../utils/const\";\n\n/**\n * Represents the configuration settings for an Aptos SDK client instance.\n * This class allows customization of various endpoints and client settings.\n *\n * @example\n * ```typescript\n * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n *\n * async function runExample() {\n *     // Create a configuration for connecting to the Aptos testnet\n *     const config = new AptosConfig({ network: Network.TESTNET });\n *\n *     // Initialize the Aptos client with the configuration\n *     const aptos = new Aptos(config);\n *\n *     console.log(\"Aptos client initialized:\", aptos);\n * }\n * runExample().catch(console.error);\n * ```\n */\nexport class AptosConfig {\n  /**\n   * The Network that this SDK is associated with. Defaults to DEVNET\n   */\n  readonly network: Network;\n\n  /**\n   * The client instance the SDK uses. Defaults to `@aptos-labs/aptos-client\n   */\n  readonly client: Client;\n\n  /**\n   * The optional hardcoded fullnode URL to send requests to instead of using the network\n   */\n  readonly fullnode?: string;\n\n  /**\n   * The optional hardcoded faucet URL to send requests to instead of using the network\n   */\n  readonly faucet?: string;\n\n  /**\n   * The optional hardcoded pepper service URL to send requests to instead of using the network\n   */\n  readonly pepper?: string;\n\n  /**\n   * The optional hardcoded prover service URL to send requests to instead of using the network\n   */\n  readonly prover?: string;\n\n  /**\n   * The optional hardcoded indexer URL to send requests to instead of using the network\n   */\n  readonly indexer?: string;\n\n  /**\n   * Optional client configurations\n   */\n  readonly clientConfig?: ClientConfig;\n\n  /**\n   * Optional specific Fullnode configurations\n   */\n  readonly fullnodeConfig?: FullNodeConfig;\n\n  /**\n   * Optional specific Indexer configurations\n   */\n  readonly indexerConfig?: IndexerConfig;\n\n  /**\n   * Optional specific Faucet configurations\n   */\n  readonly faucetConfig?: FaucetConfig;\n\n  /**\n   * Initializes an instance of the Aptos client with the specified settings.\n   * This allows users to configure various aspects of the client, such as network and endpoints.\n   *\n   * @param settings - Optional configuration settings for the Aptos client.\n   * @param settings.network - The network to connect to, defaults to `Network.DEVNET`.\n   * @param settings.fullnode - The fullnode endpoint to use for requests.\n   * @param settings.faucet - The faucet endpoint for obtaining test tokens.\n   * @param settings.pepper - The pepper used for transaction signing.\n   * @param settings.prover - The prover endpoint for transaction verification.\n   * @param settings.indexer - The indexer endpoint for querying blockchain data.\n   * @param settings.client - Custom client settings, defaults to a standard Aptos client.\n   * @param settings.clientConfig - Additional configuration for the client.\n   * @param settings.fullnodeConfig - Additional configuration for the fullnode.\n   * @param settings.indexerConfig - Additional configuration for the indexer.\n   * @param settings.faucetConfig - Additional configuration for the faucet.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a new Aptos client with default settings\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify the network\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  constructor(settings?: AptosSettings) {\n    this.network = settings?.network ?? Network.DEVNET;\n    this.fullnode = settings?.fullnode;\n    this.faucet = settings?.faucet;\n    this.pepper = settings?.pepper;\n    this.prover = settings?.prover;\n    this.indexer = settings?.indexer;\n    this.client = settings?.client ?? { provider: aptosClient };\n    this.clientConfig = settings?.clientConfig ?? {};\n    this.fullnodeConfig = settings?.fullnodeConfig ?? {};\n    this.indexerConfig = settings?.indexerConfig ?? {};\n    this.faucetConfig = settings?.faucetConfig ?? {};\n  }\n\n  /**\n   * Returns the URL endpoint to send the request to based on the specified API type.\n   * If a custom URL was provided in the configuration, that URL is returned. Otherwise, the URL endpoint is derived from the network.\n   *\n   * @param apiType - The type of Aptos API to get the URL for. This can be one of the following: FULLNODE, FAUCET, INDEXER, PEPPER, PROVER.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, AptosApiType } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Getting the request URL for the FULLNODE API\n   *   const url = config.getRequestUrl(AptosApiType.FULLNODE);\n   *   console.log(\"Request URL for FULLNODE:\", url);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  getRequestUrl(apiType: AptosApiType): string {\n    switch (apiType) {\n      case AptosApiType.FULLNODE:\n        if (this.fullnode !== undefined) return this.fullnode;\n        if (this.network === Network.CUSTOM) throw new Error(\"Please provide a custom full node url\");\n        return NetworkToNodeAPI[this.network];\n      case AptosApiType.FAUCET:\n        if (this.faucet !== undefined) return this.faucet;\n        if (this.network === Network.CUSTOM) throw new Error(\"Please provide a custom faucet url\");\n        return NetworkToFaucetAPI[this.network];\n      case AptosApiType.INDEXER:\n        if (this.indexer !== undefined) return this.indexer;\n        if (this.network === Network.CUSTOM) throw new Error(\"Please provide a custom indexer url\");\n        return NetworkToIndexerAPI[this.network];\n      case AptosApiType.PEPPER:\n        if (this.pepper !== undefined) return this.pepper;\n        if (this.network === Network.CUSTOM) throw new Error(\"Please provide a custom pepper service url\");\n        return NetworkToPepperAPI[this.network];\n      case AptosApiType.PROVER:\n        if (this.prover !== undefined) return this.prover;\n        if (this.network === Network.CUSTOM) throw new Error(\"Please provide a custom prover service url\");\n        return NetworkToProverAPI[this.network];\n      default:\n        throw Error(`apiType ${apiType} is not supported`);\n    }\n  }\n\n  /**\n   * Checks if the provided URL is a known pepper service endpoint.\n   *\n   * @param url - The URL to check against the known pepper service endpoints.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     const url = \"https://example.pepper.service\"; // replace with a real pepper service URL\n   *\n   *     // Check if the URL is a known pepper service endpoint\n   *     const isPepperService = config.isPepperServiceRequest(url);\n   *\n   *     console.log(`Is the URL a known pepper service? ${isPepperService}`);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   */\n  isPepperServiceRequest(url: string): boolean {\n    return NetworkToPepperAPI[this.network] === url;\n  }\n\n  /**\n   * Checks if the provided URL is a known prover service endpoint.\n   *\n   * @param url - The URL to check against known prover service endpoints.\n   * @returns A boolean indicating whether the URL is a known prover service endpoint.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * // Check if the URL is a known prover service endpoint\n   * const url = \"https://prover.testnet.aptos.dev\"; // replace with a real URL if needed\n   * const isProver = config.isProverServiceRequest(url);\n   *\n   * console.log(`Is the URL a known prover service? ${isProver}`);\n   * ```\n   */\n  isProverServiceRequest(url: string): boolean {\n    return NetworkToProverAPI[this.network] === url;\n  }\n}\n"]}