import{spawn as p}from"child_process";import{platform as m}from"os";var u=class{async init(e){let{network:o,profile:t,extraArguments:r,showStdout:a}=e,s=["aptos","init",`--network=${o??"local"}`,`--profile=${t??"default"}`];return r&&s.push(...r),this.runCommand(s,a)}async compile(e){let{packageDirectoryPath:o,namedAddresses:t,extraArguments:r,showStdout:a}=e,s=["aptos","move","compile","--package-dir",o],d=this.parseNamedAddresses(t);return s.push(...this.prepareNamedAddresses(d)),r&&s.push(...r),this.runCommand(s,a)}async test(e){let{packageDirectoryPath:o,namedAddresses:t,extraArguments:r,showStdout:a}=e,s=["aptos","move","test","--package-dir",o],d=this.parseNamedAddresses(t);return s.push(...this.prepareNamedAddresses(d)),r&&s.push(...r),this.runCommand(s,a)}async publish(e){let{packageDirectoryPath:o,namedAddresses:t,profile:r,extraArguments:a,showStdout:s}=e,d=["aptos","move","publish","--package-dir",o,`--profile=${r??"default"}`],n=this.parseNamedAddresses(t);return d.push(...this.prepareNamedAddresses(n)),a&&d.push(...a),this.runCommand(d,s)}async createObjectAndPublishPackage(e){let{packageDirectoryPath:o,addressName:t,namedAddresses:r,profile:a,extraArguments:s,showStdout:d}=e,n=["aptos","move","create-object-and-publish-package","--package-dir",o,"--address-name",t,`--profile=${a??"default"}`],i=this.parseNamedAddresses(r);n.push(...this.prepareNamedAddresses(i)),s&&n.push(...s);let{output:c}=await this.runCommand(n,d);return{objectAddress:this.extractAddressFromOutput(c)}}async upgradeObjectPackage(e){let{packageDirectoryPath:o,objectAddress:t,namedAddresses:r,profile:a,extraArguments:s,showStdout:d}=e,n=["aptos","move","upgrade-object-package","--package-dir",o,"--object-address",t,`--profile=${a??"default"}`],i=this.parseNamedAddresses(r);return n.push(...this.prepareNamedAddresses(i)),s&&n.push(...s),this.runCommand(n,d)}async buildPublishPayload(e){let{outputFile:o,packageDirectoryPath:t,namedAddresses:r,extraArguments:a,showStdout:s}=e,d=["aptos","move","build-publish-payload","--json-output-file",o,"--package-dir",t],n=this.parseNamedAddresses(r);return d.push(...this.prepareNamedAddresses(n)),a&&d.push(...a),this.runCommand(d,s)}async runScript(e){let{compiledScriptPath:o,profile:t,extraArguments:r,showStdout:a}=e,s=["aptos","move","run-script","--compiled-script-path",o,`--profile=${t??"default"}`];return r&&s.push(...r),this.runCommand(s,a)}async runCommand(e,o=!0){return new Promise((t,r)=>{let a=m(),s,d="",n="";a==="win32"?s=p("npx",e,{shell:!0}):s=p("npx",e),s.stdout.on("data",i=>{n=i.toString(),d+=i.toString()}),o&&(s.stdout.pipe(process.stdout),s.stderr.pipe(process.stderr)),process.stdin.pipe(s.stdin),s.on("close",i=>{if(i===0)try{let c=JSON.parse(n);c.Error?r(new Error(`Error: ${c.Error}`)):c.Result&&t({result:c.Result,output:d})}catch{t({output:d})}else r(new Error(`Child process exited with code ${i}`))})})}prepareNamedAddresses(e){let o=e.size,t=[];if(o===0)return t;t.push("--named-addresses");let r=[];return e.forEach((a,s)=>{let d=`${s}=${a.toString()}`;r.push(d)}),t.push(r.join(",")),t}parseNamedAddresses(e){let o=new Map;return Object.keys(e).forEach(t=>{let r=e[t];o.set(t,r)}),o}extractAddressFromOutput(e){let o=e.match("Code was successfully deployed to object address (0x[0-9a-fA-F]+)");if(o)return o[1];throw new Error("Failed to extract object address from output")}};export{u as a};
//# sourceMappingURL=chunk-AITN3DO4.mjs.map