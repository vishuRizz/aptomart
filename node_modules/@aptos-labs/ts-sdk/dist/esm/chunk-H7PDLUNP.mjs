import{a as O,b as _}from"./chunk-TQA6HY6A.mjs";import{d as E}from"./chunk-OEM75TVE.mjs";import{a as R}from"./chunk-LZ5PSDOS.mjs";import{a as P,b as w}from"./chunk-KKLF7DQV.mjs";import{a as I}from"./chunk-FUC7SLH7.mjs";import{i as T,j as b,k as x,n as g,q as v,s as k}from"./chunk-B5BXB2BB.mjs";import{b as m}from"./chunk-JNO7KPMG.mjs";import{d as r}from"./chunk-F45G3GP3.mjs";import{a as K}from"./chunk-AJ5JHBAE.mjs";import{b as h}from"./chunk-SPRNSFUV.mjs";import{e as F}from"./chunk-V4FKFCBL.mjs";import C from"eventemitter3";import{jwtDecode as D}from"jwt-decode";function se(f){return f!=null&&typeof f.checkKeylessAccountValidity=="function"}var p=class p extends K{constructor(e){super();let{address:i,ephemeralKeyPair:t,publicKey:o,uidKey:y,uidVal:n,aud:c,pepper:s,proof:a,proofFetchCallback:l,jwt:d,verificationKeyHash:u}=e;if(this.ephemeralKeyPair=t,this.publicKey=o,this.accountAddress=i?m.from(i):this.publicKey.authKey().derivedAddress(),this.uidKey=y,this.uidVal=n,this.aud=c,this.jwt=d,this.emitter=new C,this.proofOrPromise=a,a instanceof g)this.proof=a;else{if(l===void 0)throw new Error("Must provide callback for async proof fetch");this.emitter.on("proofFetchFinish",async N=>{await l(N),this.emitter.removeAllListeners()}),this.init(a)}this.signingScheme=2;let S=h.fromHexInput(s).toUint8Array();if(S.length!==p.PEPPER_LENGTH)throw new Error(`Pepper length in bytes should be ${p.PEPPER_LENGTH}`);if(this.pepper=S,u!==void 0){if(h.hexInputToUint8Array(u).length!==32)throw new Error("verificationKeyHash must be 32 bytes");this.verificationKeyHash=h.hexInputToUint8Array(u)}}async init(e){try{this.proof=await e,this.emitter.emit("proofFetchFinish",{status:"Success"})}catch(i){i instanceof Error?this.emitter.emit("proofFetchFinish",{status:"Failed",error:i.toString()}):this.emitter.emit("proofFetchFinish",{status:"Failed",error:"Unknown"})}}serialize(e){if(this.accountAddress.serialize(e),e.serializeStr(this.jwt),e.serializeStr(this.uidKey),e.serializeFixedBytes(this.pepper),this.ephemeralKeyPair.serialize(e),this.proof===void 0)throw new Error("Cannot serialize - proof undefined");this.proof.serialize(e),e.serializeOption(this.verificationKeyHash,32)}static partialDeserialize(e){let i=m.deserialize(e),t=e.deserializeStr(),o=e.deserializeStr(),y=e.deserializeFixedBytes(31),n=R.deserialize(e),c=g.deserialize(e),s=e.deserializeOption("fixedBytes",32);return{address:i,jwt:t,uidKey:o,pepper:y,ephemeralKeyPair:n,proof:c,verificationKeyHash:s}}isExpired(){return this.ephemeralKeyPair.isExpired()}signWithAuthenticator(e){let i=new w(this.sign(e)),t=new P(this.publicKey);return new E(t,i)}signTransactionWithAuthenticator(e){let i=new w(this.signTransaction(e)),t=new P(this.publicKey);return new E(t,i)}async waitForProofFetch(){this.proofOrPromise instanceof Promise&&await this.proofOrPromise}async checkKeylessAccountValidity(e){if(this.isExpired())throw r.fromErrorType({type:0});if(await this.waitForProofFetch(),this.proof===void 0)throw r.fromErrorType({type:2});let i=D(this.jwt,{header:!0});if(i.kid===void 0)throw r.fromErrorType({type:12,details:"checkKeylessAccountValidity failed. JWT is missing 'kid' in header. This should never happen."});if(this.verificationKeyHash!==void 0){let{verificationKey:t}=await v({aptosConfig:e});if(h.hexInputToString(t.hash())!==h.hexInputToString(this.verificationKeyHash))throw r.fromErrorType({type:4})}else console.warn("[Aptos SDK] The verification key hash was not set. Proof may be invalid if the verification key has rotated.");await p.fetchJWK({aptosConfig:e,publicKey:this.publicKey,kid:i.kid})}sign(e){let{expiryDateSecs:i}=this.ephemeralKeyPair;if(this.isExpired())throw r.fromErrorType({type:0});if(this.proof===void 0)throw r.fromErrorType({type:1,details:"Proof not found - make sure to call `await account.checkKeylessAccountValidity()` before signing."});let t=this.ephemeralKeyPair.getPublicKey(),o=this.ephemeralKeyPair.sign(e);return new b({jwtHeader:F(this.jwt.split(".")[0]),ephemeralCertificate:new x(this.proof,0),expiryDateSecs:i,ephemeralPublicKey:t,ephemeralSignature:o})}signTransaction(e){if(this.proof===void 0)throw r.fromErrorType({type:1,details:"Proof not found - make sure to call `await account.checkKeylessAccountValidity()` before signing."});let i=O(e),o=new A(i,this.proof.proof).hash();return this.sign(o)}verifySignature(e){let{message:i,signature:t}=e;return!(this.isExpired()||!this.ephemeralKeyPair.getPublicKey().verifySignature({message:i,signature:t.ephemeralSignature}))}static async fetchJWK(e){let{aptosConfig:i,publicKey:t,kid:o}=e,y=t instanceof T?t:t.keylessPublicKey,{iss:n}=y,c,s=t instanceof I?t.jwkAddress:void 0;try{c=await k({aptosConfig:i,jwkAddr:s})}catch(d){throw r.fromErrorType({type:24,error:d,details:`Failed to fetch ${s?"Federated":"Patched"}JWKs ${s?`for address ${s}`:"0x1"}`})}let a=c.get(n);if(a===void 0)throw r.fromErrorType({type:7,details:`JWKs for issuer ${n} not found.`});let l=a.find(d=>d.kid===o);if(l===void 0)throw r.fromErrorType({type:6,details:`JWK with kid '${o}' for issuer '${n}' not found.`});return l}};p.PEPPER_LENGTH=31;var H=p,A=class extends K{constructor(i,t){super();this.domainSeparator="APTOS::TransactionAndProof";this.transaction=i,this.proof=t}serialize(i){i.serializeFixedBytes(this.transaction.bcsToBytes()),i.serializeOption(this.proof)}hash(){return _(this.bcsToBytes(),this.domainSeparator)}};export{se as a,H as b,A as c};
//# sourceMappingURL=chunk-H7PDLUNP.mjs.map