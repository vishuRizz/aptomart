{"version":3,"sources":["../../src/core/crypto/keyless.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n// eslint-disable-next-line max-classes-per-file\nimport { JwtPayload, jwtDecode } from \"jwt-decode\";\nimport { sha3_256 } from \"@noble/hashes/sha3\";\nimport { AccountPublicKey, PublicKey } from \"./publicKey\";\nimport { Signature } from \"./signature\";\nimport { Deserializer, Serializable, Serializer } from \"../../bcs\";\nimport { Hex, hexToAsciiString } from \"../hex\";\nimport {\n  HexInput,\n  EphemeralCertificateVariant,\n  AnyPublicKeyVariant,\n  SigningScheme,\n  ZkpVariant,\n  LedgerVersionArg,\n  MoveResource,\n} from \"../../types\";\nimport { EphemeralPublicKey, EphemeralSignature } from \"./ephemeral\";\nimport { bigIntToBytesLE, bytesToBigIntLE, hashStrToField, poseidonHash } from \"./poseidon\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { Proof } from \"./proof\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"./ed25519\";\nimport {\n  Groth16VerificationKeyResponse,\n  KeylessConfigurationResponse,\n  MoveAnyStruct,\n  PatchedJWKsResponse,\n} from \"../../types/keyless\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { getAptosFullNode } from \"../../client\";\nimport { memoizeAsync } from \"../../utils/memoize\";\nimport { AccountAddress, AccountAddressInput } from \"../accountAddress\";\nimport { getErrorMessage } from \"../../utils\";\nimport { KeylessError, KeylessErrorType } from \"../../errors\";\n\nexport const EPK_HORIZON_SECS = 10000000;\nexport const MAX_AUD_VAL_BYTES = 120;\nexport const MAX_UID_KEY_BYTES = 30;\nexport const MAX_UID_VAL_BYTES = 330;\nexport const MAX_ISS_VAL_BYTES = 120;\nexport const MAX_EXTRA_FIELD_BYTES = 350;\nexport const MAX_JWT_HEADER_B64_BYTES = 300;\nexport const MAX_COMMITED_EPK_BYTES = 93;\n\n/**\n * Represents a Keyless Public Key used for authentication.\n *\n * This class encapsulates the public key functionality for keyless authentication,\n * including methods for generating and verifying signatures, as well as serialization\n * and deserialization of the key. The KeylessPublicKey is represented in the SDK\n * as `AnyPublicKey`.\n */\nexport class KeylessPublicKey extends AccountPublicKey {\n  /**\n   * The number of bytes that `idCommitment` should be\n   */\n  static readonly ID_COMMITMENT_LENGTH: number = 32;\n\n  /**\n   * The value of the 'iss' claim on the JWT which identifies the OIDC provider.\n   */\n  readonly iss: string;\n\n  /**\n   * A value representing a cryptographic commitment to a user identity.\n   *\n   * It is calculated from the aud, uidKey, uidVal, pepper.\n   */\n  readonly idCommitment: Uint8Array;\n\n  /**\n   * Constructs an instance with the specified parameters for cryptographic operations.\n   *\n   * @param args - The parameters required to initialize the instance.\n   * @param args.alphaG1 - The hex representation of the alpha G1 value.\n   * @param args.betaG2 - The hex representation of the beta G2 value.\n   * @param args.deltaG2 - The hex representation of the delta G2 value.\n   * @param args.gammaAbcG1 - An array containing two hex representations for gamma ABC G1 values.\n   * @param args.gammaG2 - The hex representation of the gamma G2 value.\n   */\n  // TODO: Fix the JSDoc for the below values\n  constructor(iss: string, idCommitment: HexInput) {\n    super();\n    const idcBytes = Hex.fromHexInput(idCommitment).toUint8Array();\n    if (idcBytes.length !== KeylessPublicKey.ID_COMMITMENT_LENGTH) {\n      throw new Error(`Id Commitment length in bytes should be ${KeylessPublicKey.ID_COMMITMENT_LENGTH}`);\n    }\n    this.iss = iss;\n    this.idCommitment = idcBytes;\n  }\n\n  /**\n   * Get the authentication key for the keyless public key.\n   *\n   * @returns AuthenticationKey - The authentication key derived from the keyless public key.\n   */\n  authKey(): AuthenticationKey {\n    const serializer = new Serializer();\n    serializer.serializeU32AsUleb128(AnyPublicKeyVariant.Keyless);\n    serializer.serializeFixedBytes(this.bcsToBytes());\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: SigningScheme.SingleKey,\n      input: serializer.toUint8Array(),\n    });\n  }\n\n  /**\n   * Verifies the validity of a signature for a given message.\n   *\n   * @param args - The arguments for signature verification.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify against the message.\n   * @returns true if the signature is valid; otherwise, false.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, class-methods-use-this\n  verifySignature(args: { message: HexInput; signature: KeylessSignature }): boolean {\n    throw new Error(\"Not yet implemented\");\n  }\n\n  /**\n   * Serializes the current instance into a format suitable for transmission or storage.\n   * This function ensures that all relevant fields are properly serialized, including the proof and optional fields.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @param serializer.proof - The proof to be serialized.\n   * @param serializer.expHorizonSecs - The expiration horizon in seconds.\n   * @param serializer.extraField - An optional additional field for serialization.\n   * @param serializer.overrideAudVal - An optional override value for auditing.\n   * @param serializer.trainingWheelsSignature - An optional signature for training wheels.\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.iss);\n    serializer.serializeBytes(this.idCommitment);\n  }\n\n  /**\n   * Deserializes a ZeroKnowledgeSig object from the provided deserializer.\n   * This function allows you to reconstruct a ZeroKnowledgeSig instance from its serialized form.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @returns A new instance of ZeroKnowledgeSig.\n   */\n  static deserialize(deserializer: Deserializer): KeylessPublicKey {\n    const iss = deserializer.deserializeStr();\n    const addressSeed = deserializer.deserializeBytes();\n    return new KeylessPublicKey(iss, addressSeed);\n  }\n\n  /**\n   * Loads a KeylessPublicKey instance from the provided deserializer.\n   * This function is used to deserialize the necessary components to create a KeylessPublicKey.\n   *\n   * @param deserializer - The deserializer used to extract the string and byte data.\n   * @param deserializer.deserializeStr - A method to deserialize a string value.\n   * @param deserializer.deserializeBytes - A method to deserialize byte data.\n   * @returns A new instance of KeylessPublicKey.\n   */\n  static load(deserializer: Deserializer): KeylessPublicKey {\n    const iss = deserializer.deserializeStr();\n    const addressSeed = deserializer.deserializeBytes();\n    return new KeylessPublicKey(iss, addressSeed);\n  }\n\n  /**\n   * Determines if the provided public key is an instance of KeylessPublicKey.\n   *\n   * @param publicKey - The public key to check.\n   * @returns A boolean indicating whether the public key is a KeylessPublicKey instance.\n   */\n  static isPublicKey(publicKey: PublicKey): publicKey is KeylessPublicKey {\n    return publicKey instanceof KeylessPublicKey;\n  }\n\n  /**\n   * Creates a KeylessPublicKey from the JWT components plus pepper\n   *\n   * @param args.iss the iss of the identity\n   * @param args.uidKey the key to use to get the uidVal in the JWT token\n   * @param args.uidVal the value of the uidKey in the JWT token\n   * @param args.aud the client ID of the application\n   * @param args.pepper The pepper used to maintain privacy of the account\n   * @returns KeylessPublicKey\n   */\n  static create(args: {\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n  }): KeylessPublicKey {\n    computeIdCommitment(args);\n    return new KeylessPublicKey(args.iss, computeIdCommitment(args));\n  }\n\n  /**\n   * Creates a KeylessPublicKey instance from a JWT and a pepper value.\n   * This function is useful for generating a public key that can be used for authentication based on the provided JWT claims and pepper.\n   *\n   * @param args - The arguments for creating the KeylessPublicKey.\n   * @param args.jwt - The JSON Web Token to decode.\n   * @param args.pepper - The pepper value used in the key creation process.\n   * @param args.uidKey - An optional key to retrieve the unique identifier from the JWT payload, defaults to \"sub\".\n   * @returns A KeylessPublicKey instance created from the provided JWT and pepper.\n   */\n  static fromJwtAndPepper(args: { jwt: string; pepper: HexInput; uidKey?: string }): KeylessPublicKey {\n    const { jwt, pepper, uidKey = \"sub\" } = args;\n    const jwtPayload = jwtDecode<JwtPayload & { [key: string]: string }>(jwt);\n    if (typeof jwtPayload.iss !== \"string\") {\n      throw new Error(\"iss was not found\");\n    }\n    if (typeof jwtPayload.aud !== \"string\") {\n      throw new Error(\"aud was not found or an array of values\");\n    }\n    const uidVal = jwtPayload[uidKey];\n    return KeylessPublicKey.create({ iss: jwtPayload.iss, uidKey, uidVal, aud: jwtPayload.aud, pepper });\n  }\n\n  /**\n   * Checks if the provided public key is a valid instance by verifying its structure and types.\n   *\n   * @param publicKey - The public key to validate.\n   * @returns A boolean indicating whether the public key is a valid instance.\n   */\n  static isInstance(publicKey: PublicKey) {\n    return (\n      \"iss\" in publicKey &&\n      typeof publicKey.iss === \"string\" &&\n      \"idCommitment\" in publicKey &&\n      publicKey.idCommitment instanceof Uint8Array\n    );\n  }\n}\n\nfunction computeIdCommitment(args: { uidKey: string; uidVal: string; aud: string; pepper: HexInput }): Uint8Array {\n  const { uidKey, uidVal, aud, pepper } = args;\n\n  const fields = [\n    bytesToBigIntLE(Hex.fromHexInput(pepper).toUint8Array()),\n    hashStrToField(aud, MAX_AUD_VAL_BYTES),\n    hashStrToField(uidVal, MAX_UID_VAL_BYTES),\n    hashStrToField(uidKey, MAX_UID_KEY_BYTES),\n  ];\n\n  return bigIntToBytesLE(poseidonHash(fields), KeylessPublicKey.ID_COMMITMENT_LENGTH);\n}\n\n/**\n * Represents a signature of a message signed via a Keyless Account, utilizing proofs or a JWT token for authentication.\n */\nexport class KeylessSignature extends Signature {\n  /**\n   * The inner signature ZeroKnowledgeSignature or OpenIdSignature\n   */\n  readonly ephemeralCertificate: EphemeralCertificate;\n\n  /**\n   * The jwt header in the token used to create the proof/signature.  In json string representation.\n   */\n  readonly jwtHeader: string;\n\n  /**\n   * The expiry timestamp in seconds of the EphemeralKeyPair used to sign\n   */\n  readonly expiryDateSecs: number;\n\n  /**\n   * The ephemeral public key used to verify the signature\n   */\n  readonly ephemeralPublicKey: EphemeralPublicKey;\n\n  /**\n   * The signature resulting from signing with the private key of the EphemeralKeyPair\n   */\n  readonly ephemeralSignature: EphemeralSignature;\n\n  constructor(args: {\n    jwtHeader: string;\n    ephemeralCertificate: EphemeralCertificate;\n    expiryDateSecs: number;\n    ephemeralPublicKey: EphemeralPublicKey;\n    ephemeralSignature: EphemeralSignature;\n  }) {\n    super();\n    const { jwtHeader, ephemeralCertificate, expiryDateSecs, ephemeralPublicKey, ephemeralSignature } = args;\n    this.jwtHeader = jwtHeader;\n    this.ephemeralCertificate = ephemeralCertificate;\n    this.expiryDateSecs = expiryDateSecs;\n    this.ephemeralPublicKey = ephemeralPublicKey;\n    this.ephemeralSignature = ephemeralSignature;\n  }\n\n  /**\n   * Get the kid of the JWT used to derive the Keyless Account used to sign.\n   *\n   * @returns the kid as a string\n   */\n  getJwkKid(): string {\n    return parseJwtHeader(this.jwtHeader).kid;\n  }\n\n  serialize(serializer: Serializer): void {\n    this.ephemeralCertificate.serialize(serializer);\n    serializer.serializeStr(this.jwtHeader);\n    serializer.serializeU64(this.expiryDateSecs);\n    this.ephemeralPublicKey.serialize(serializer);\n    this.ephemeralSignature.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): KeylessSignature {\n    const ephemeralCertificate = EphemeralCertificate.deserialize(deserializer);\n    const jwtHeader = deserializer.deserializeStr();\n    const expiryDateSecs = deserializer.deserializeU64();\n    const ephemeralPublicKey = EphemeralPublicKey.deserialize(deserializer);\n    const ephemeralSignature = EphemeralSignature.deserialize(deserializer);\n    return new KeylessSignature({\n      jwtHeader,\n      expiryDateSecs: Number(expiryDateSecs),\n      ephemeralCertificate,\n      ephemeralPublicKey,\n      ephemeralSignature,\n    });\n  }\n\n  static getSimulationSignature(): KeylessSignature {\n    return new KeylessSignature({\n      jwtHeader: \"{}\",\n      ephemeralCertificate: new EphemeralCertificate(\n        new ZeroKnowledgeSig({\n          proof: new ZkProof(\n            new Groth16Zkp({ a: new Uint8Array(32), b: new Uint8Array(64), c: new Uint8Array(32) }),\n            ZkpVariant.Groth16,\n          ),\n          expHorizonSecs: 0,\n        }),\n        EphemeralCertificateVariant.ZkProof,\n      ),\n      expiryDateSecs: 0,\n      ephemeralPublicKey: new EphemeralPublicKey(new Ed25519PublicKey(new Uint8Array(32))),\n      ephemeralSignature: new EphemeralSignature(new Ed25519Signature(new Uint8Array(64))),\n    });\n  }\n\n  static isSignature(signature: Signature): signature is KeylessSignature {\n    return signature instanceof KeylessSignature;\n  }\n}\n\n/**\n * Represents an ephemeral certificate containing a signature, specifically a ZeroKnowledgeSig.\n * This class can be extended to support additional signature types, such as OpenIdSignature.\n *\n * @extends Signature\n */\nexport class EphemeralCertificate extends Signature {\n  public readonly signature: Signature;\n\n  /**\n   * Index of the underlying enum variant\n   */\n  private readonly variant: EphemeralCertificateVariant;\n\n  constructor(signature: Signature, variant: EphemeralCertificateVariant) {\n    super();\n    this.signature = signature;\n    this.variant = variant;\n  }\n\n  /**\n   * Get the public key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the public key\n   */\n  toUint8Array(): Uint8Array {\n    return this.signature.toUint8Array();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.variant);\n    this.signature.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): EphemeralCertificate {\n    const variant = deserializer.deserializeUleb128AsU32();\n    switch (variant) {\n      case EphemeralCertificateVariant.ZkProof:\n        return new EphemeralCertificate(ZeroKnowledgeSig.deserialize(deserializer), variant);\n      default:\n        throw new Error(`Unknown variant index for EphemeralCertificate: ${variant}`);\n    }\n  }\n}\n\n/**\n * Represents a fixed-size byte array of 32 bytes, extending the Serializable class.\n * This class is used for handling and serializing G1 bytes in cryptographic operations.\n *\n * @extends Serializable\n */\nclass G1Bytes extends Serializable {\n  data: Uint8Array;\n\n  constructor(data: HexInput) {\n    super();\n    this.data = Hex.fromHexInput(data).toUint8Array();\n    if (this.data.length !== 32) {\n      throw new Error(\"Input needs to be 32 bytes\");\n    }\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.data);\n  }\n\n  static deserialize(deserializer: Deserializer): G1Bytes {\n    const bytes = deserializer.deserializeFixedBytes(32);\n    return new G1Bytes(bytes);\n  }\n}\n\n/**\n * Represents a 64-byte G2 element in a cryptographic context.\n * This class provides methods for serialization and deserialization of G2 bytes.\n *\n * @extends Serializable\n */\nclass G2Bytes extends Serializable {\n  data: Uint8Array;\n\n  constructor(data: HexInput) {\n    super();\n    this.data = Hex.fromHexInput(data).toUint8Array();\n    if (this.data.length !== 64) {\n      throw new Error(\"Input needs to be 64 bytes\");\n    }\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.data);\n  }\n\n  static deserialize(deserializer: Deserializer): G2Bytes {\n    const bytes = deserializer.deserializeFixedBytes(64);\n    return new G2Bytes(bytes);\n  }\n}\n\n/**\n * Represents a Groth16 zero-knowledge proof, consisting of three proof points in compressed serialization format.\n * The points are the compressed serialization of affine representation of the proof.\n *\n * @extends Proof\n */\nexport class Groth16Zkp extends Proof {\n  /**\n   * The bytes of G1 proof point a\n   */\n  a: G1Bytes;\n\n  /**\n   * The bytes of G2 proof point b\n   */\n  b: G2Bytes;\n\n  /**\n   * The bytes of G1 proof point c\n   */\n  c: G1Bytes;\n\n  constructor(args: { a: HexInput; b: HexInput; c: HexInput }) {\n    super();\n    const { a, b, c } = args;\n    this.a = new G1Bytes(a);\n    this.b = new G2Bytes(b);\n    this.c = new G1Bytes(c);\n  }\n\n  serialize(serializer: Serializer): void {\n    this.a.serialize(serializer);\n    this.b.serialize(serializer);\n    this.c.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): Groth16Zkp {\n    const a = G1Bytes.deserialize(deserializer).bcsToBytes();\n    const b = G2Bytes.deserialize(deserializer).bcsToBytes();\n    const c = G1Bytes.deserialize(deserializer).bcsToBytes();\n    return new Groth16Zkp({ a, b, c });\n  }\n}\n\n/**\n * Represents a container for different types of zero-knowledge proofs.\n *\n * @extends Serializable\n */\nexport class ZkProof extends Serializable {\n  public readonly proof: Proof;\n\n  /**\n   * Index of the underlying enum variant\n   */\n  private readonly variant: ZkpVariant;\n\n  constructor(proof: Proof, variant: ZkpVariant) {\n    super();\n    this.proof = proof;\n    this.variant = variant;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.variant);\n    this.proof.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): ZkProof {\n    const variant = deserializer.deserializeUleb128AsU32();\n    switch (variant) {\n      case ZkpVariant.Groth16:\n        return new ZkProof(Groth16Zkp.deserialize(deserializer), variant);\n      default:\n        throw new Error(`Unknown variant index for ZkProof: ${variant}`);\n    }\n  }\n}\n\n/**\n * Represents a zero-knowledge signature, encapsulating the proof and its associated metadata.\n *\n * @extends Signature\n */\nexport class ZeroKnowledgeSig extends Signature {\n  /**\n   * The proof\n   */\n  readonly proof: ZkProof;\n\n  /**\n   * The max lifespan of the proof\n   */\n  readonly expHorizonSecs: number;\n\n  /**\n   * A key value pair on the JWT token that can be specified on the signature which would reveal the value on chain.\n   * Can be used to assert identity or other attributes.\n   */\n  readonly extraField?: string;\n\n  /**\n   * The 'aud' value of the recovery service which is set when recovering an account.\n   */\n  readonly overrideAudVal?: string;\n\n  /**\n   * The training wheels signature\n   */\n  readonly trainingWheelsSignature?: EphemeralSignature;\n\n  constructor(args: {\n    proof: ZkProof;\n    expHorizonSecs: number;\n    extraField?: string;\n    overrideAudVal?: string;\n    trainingWheelsSignature?: EphemeralSignature;\n  }) {\n    super();\n    const { proof, expHorizonSecs, trainingWheelsSignature, extraField, overrideAudVal } = args;\n    this.proof = proof;\n    this.expHorizonSecs = expHorizonSecs;\n    this.trainingWheelsSignature = trainingWheelsSignature;\n    this.extraField = extraField;\n    this.overrideAudVal = overrideAudVal;\n  }\n\n  /**\n   * Deserialize a ZeroKnowledgeSig object from its BCS serialization in bytes.\n   *\n   * @param bytes - The bytes representing the serialized ZeroKnowledgeSig.\n   * @returns ZeroKnowledgeSig - The deserialized ZeroKnowledgeSig object.\n   */\n  static fromBytes(bytes: Uint8Array): ZeroKnowledgeSig {\n    return ZeroKnowledgeSig.deserialize(new Deserializer(bytes));\n  }\n\n  serialize(serializer: Serializer): void {\n    this.proof.serialize(serializer);\n    serializer.serializeU64(this.expHorizonSecs);\n    serializer.serializeOption(this.extraField);\n    serializer.serializeOption(this.overrideAudVal);\n    serializer.serializeOption(this.trainingWheelsSignature);\n  }\n\n  static deserialize(deserializer: Deserializer): ZeroKnowledgeSig {\n    const proof = ZkProof.deserialize(deserializer);\n    const expHorizonSecs = Number(deserializer.deserializeU64());\n    const extraField = deserializer.deserializeOption(\"string\");\n    const overrideAudVal = deserializer.deserializeOption(\"string\");\n    const trainingWheelsSignature = deserializer.deserializeOption(EphemeralSignature);\n    return new ZeroKnowledgeSig({ proof, expHorizonSecs, trainingWheelsSignature, extraField, overrideAudVal });\n  }\n}\n\n/**\n * Represents the on-chain configuration for how Keyless accounts operate.\n *\n * @remarks\n * This class encapsulates the verification key and the maximum lifespan of ephemeral key pairs,\n * which are essential for the functionality of Keyless accounts.\n */\nexport class KeylessConfiguration {\n  /**\n   * The verification key used to verify Groth16 proofs on chain\n   */\n  readonly verificationKey: Groth16VerificationKey;\n\n  /**\n   * The maximum lifespan of an ephemeral key pair.  This is configured on chain.\n   */\n  readonly maxExpHorizonSecs: number;\n\n  constructor(verificationKey: Groth16VerificationKey, maxExpHorizonSecs: number) {\n    this.verificationKey = verificationKey;\n    this.maxExpHorizonSecs = maxExpHorizonSecs;\n  }\n\n  static create(res: Groth16VerificationKeyResponse, maxExpHorizonSecs: number): KeylessConfiguration {\n    return new KeylessConfiguration(\n      new Groth16VerificationKey({\n        alphaG1: res.alpha_g1,\n        betaG2: res.beta_g2,\n        deltaG2: res.delta_g2,\n        gammaAbcG1: res.gamma_abc_g1,\n        gammaG2: res.gamma_g2,\n      }),\n      maxExpHorizonSecs,\n    );\n  }\n}\n\n/**\n * Represents the verification key stored on-chain used to verify Groth16 proofs.\n */\nexport class Groth16VerificationKey {\n  // The docstrings below are borrowed from ark-groth16\n\n  /**\n   * The `alpha * G`, where `G` is the generator of G1\n   */\n  readonly alphaG1: G1Bytes;\n\n  /**\n   * The `alpha * H`, where `H` is the generator of G2\n   */\n  readonly betaG2: G2Bytes;\n\n  /**\n   * The `delta * H`, where `H` is the generator of G2\n   */\n  readonly deltaG2: G2Bytes;\n\n  /**\n   * The `gamma^{-1} * (beta * a_i + alpha * b_i + c_i) * H`, where H is the generator of G1\n   */\n  readonly gammaAbcG1: [G1Bytes, G1Bytes];\n\n  /**\n   * The `gamma * H`, where `H` is the generator of G2\n   */\n  readonly gammaG2: G2Bytes;\n\n  constructor(args: {\n    alphaG1: HexInput;\n    betaG2: HexInput;\n    deltaG2: HexInput;\n    gammaAbcG1: [HexInput, HexInput];\n    gammaG2: HexInput;\n  }) {\n    const { alphaG1, betaG2, deltaG2, gammaAbcG1, gammaG2 } = args;\n    this.alphaG1 = new G1Bytes(alphaG1);\n    this.betaG2 = new G2Bytes(betaG2);\n    this.deltaG2 = new G2Bytes(deltaG2);\n    this.gammaAbcG1 = [new G1Bytes(gammaAbcG1[0]), new G1Bytes(gammaAbcG1[1])];\n    this.gammaG2 = new G2Bytes(gammaG2);\n  }\n\n  /**\n   * Calculates the hash of the serialized form of the verification key.\n   * This is useful for comparing verification keys or using them as unique identifiers.\n   *\n   * @returns The SHA3-256 hash of the serialized verification key as a Uint8Array\n   */\n  public hash(): Uint8Array {\n    const serializer = new Serializer();\n    this.serialize(serializer);\n    return sha3_256.create().update(serializer.toUint8Array()).digest();\n  }\n\n  serialize(serializer: Serializer): void {\n    this.alphaG1.serialize(serializer);\n    this.betaG2.serialize(serializer);\n    this.deltaG2.serialize(serializer);\n    this.gammaAbcG1[0].serialize(serializer);\n    this.gammaAbcG1[1].serialize(serializer);\n    this.gammaG2.serialize(serializer);\n  }\n\n  /**\n   * Converts a Groth16VerificationKeyResponse object into a Groth16VerificationKey instance.\n   *\n   * @param res - The Groth16VerificationKeyResponse object containing the verification key data.\n   * @param res.alpha_g1 - The alpha G1 value from the response.\n   * @param res.beta_g2 - The beta G2 value from the response.\n   * @param res.delta_g2 - The delta G2 value from the response.\n   * @param res.gamma_abc_g1 - The gamma ABC G1 value from the response.\n   * @param res.gamma_g2 - The gamma G2 value from the response.\n   * @returns A Groth16VerificationKey instance constructed from the provided response data.\n   */\n  static fromGroth16VerificationKeyResponse(res: Groth16VerificationKeyResponse): Groth16VerificationKey {\n    return new Groth16VerificationKey({\n      alphaG1: res.alpha_g1,\n      betaG2: res.beta_g2,\n      deltaG2: res.delta_g2,\n      gammaAbcG1: res.gamma_abc_g1,\n      gammaG2: res.gamma_g2,\n    });\n  }\n}\n\n/**\n * Retrieves the configuration parameters for Keyless Accounts on the blockchain, including the verifying key and the maximum\n * expiry horizon.\n *\n * @param args - The arguments for retrieving the keyless configuration.\n * @param args.aptosConfig - The Aptos configuration object containing network details.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - The ledger version to query; if not provided, the latest version will be used.\n * @returns KeylessConfiguration - The configuration object containing the verifying key and maximum expiry horizon.\n */\nexport async function getKeylessConfig(args: {\n  aptosConfig: AptosConfig;\n  options?: LedgerVersionArg;\n}): Promise<KeylessConfiguration> {\n  const { aptosConfig } = args;\n  try {\n    return await memoizeAsync(\n      async () => {\n        const config = await getKeylessConfigurationResource(args);\n        const vk = await getGroth16VerificationKeyResource(args);\n        return KeylessConfiguration.create(vk, Number(config.max_exp_horizon_secs));\n      },\n      `keyless-configuration-${aptosConfig.network}`,\n      1000 * 60 * 5, // 5 minutes\n    )();\n  } catch (error) {\n    if (error instanceof KeylessError) {\n      throw error;\n    }\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.FULL_NODE_OTHER,\n      error,\n    });\n  }\n}\n\n/**\n * Parses a JWT and returns the 'iss', 'aud', and 'uid' values.\n *\n * @param args - The arguments for parsing the JWT.\n * @param args.jwt - The JWT to parse.\n * @param args.uidKey - The key to use for the 'uid' value; defaults to 'sub'.\n * @returns The 'iss', 'aud', and 'uid' values from the JWT.\n */\nexport function getIssAudAndUidVal(args: { jwt: string; uidKey?: string }): {\n  iss: string;\n  aud: string;\n  uidVal: string;\n} {\n  const { jwt, uidKey = \"sub\" } = args;\n  let jwtPayload: JwtPayload & { [key: string]: string };\n  try {\n    jwtPayload = jwtDecode<JwtPayload & { [key: string]: string }>(jwt);\n  } catch (error) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.JWT_PARSING_ERROR,\n      details: `Failed to parse JWT - ${getErrorMessage(error)}`,\n    });\n  }\n  if (typeof jwtPayload.iss !== \"string\") {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.JWT_PARSING_ERROR,\n      details: \"JWT is missing 'iss' in the payload. This should never happen.\",\n    });\n  }\n  if (typeof jwtPayload.aud !== \"string\") {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.JWT_PARSING_ERROR,\n      details: \"JWT is missing 'aud' in the payload or 'aud' is an array of values.\",\n    });\n  }\n  const uidVal = jwtPayload[uidKey];\n  return { iss: jwtPayload.iss, aud: jwtPayload.aud, uidVal };\n}\n\n/**\n * Retrieves the KeylessConfiguration set on chain.\n *\n * @param args - The arguments for retrieving the configuration.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n * @returns KeylessConfigurationResponse - The response containing the keyless configuration data.\n */\nasync function getKeylessConfigurationResource(args: {\n  aptosConfig: AptosConfig;\n  options?: LedgerVersionArg;\n}): Promise<KeylessConfigurationResponse> {\n  const { aptosConfig, options } = args;\n  const resourceType = \"0x1::keyless_account::Configuration\";\n  try {\n    const { data } = await getAptosFullNode<{}, MoveResource<KeylessConfigurationResponse>>({\n      aptosConfig,\n      originMethod: \"getKeylessConfigurationResource\",\n      path: `accounts/${AccountAddress.from(\"0x1\").toString()}/resource/${resourceType}`,\n      params: { ledger_version: options?.ledgerVersion },\n    });\n    return data.data;\n  } catch (error) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.FULL_NODE_CONFIG_LOOKUP_ERROR,\n      error,\n    });\n  }\n}\n\n/**\n * Retrieves the Groth16VerificationKey set on the blockchain.\n *\n * @param args - The arguments for retrieving the verification key.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n * @returns Groth16VerificationKeyResponse - The response containing the Groth16 verification key data.\n */\nasync function getGroth16VerificationKeyResource(args: {\n  aptosConfig: AptosConfig;\n  options?: LedgerVersionArg;\n}): Promise<Groth16VerificationKeyResponse> {\n  const { aptosConfig, options } = args;\n  const resourceType = \"0x1::keyless_account::Groth16VerificationKey\";\n  try {\n    const { data } = await getAptosFullNode<{}, MoveResource<Groth16VerificationKeyResponse>>({\n      aptosConfig,\n      originMethod: \"getGroth16VerificationKeyResource\",\n      path: `accounts/${AccountAddress.from(\"0x1\").toString()}/resource/${resourceType}`,\n      params: { ledger_version: options?.ledgerVersion },\n    });\n    return data.data;\n  } catch (error) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.FULL_NODE_VERIFICATION_KEY_LOOKUP_ERROR,\n      error,\n    });\n  }\n}\n\nexport async function getKeylessJWKs(args: {\n  aptosConfig: AptosConfig;\n  jwkAddr?: AccountAddressInput;\n  options?: LedgerVersionArg;\n}): Promise<Map<string, MoveJWK[]>> {\n  const { aptosConfig, jwkAddr, options } = args;\n  let resource: MoveResource<PatchedJWKsResponse>;\n  if (!jwkAddr) {\n    const resourceType = \"0x1::jwks::PatchedJWKs\";\n    const { data } = await getAptosFullNode<{}, MoveResource<PatchedJWKsResponse>>({\n      aptosConfig,\n      originMethod: \"getKeylessJWKs\",\n      path: `accounts/0x1/resource/${resourceType}`,\n      params: { ledger_version: options?.ledgerVersion },\n    });\n    resource = data;\n  } else {\n    const resourceType = \"0x1::jwks::FederatedJWKs\";\n    const { data } = await getAptosFullNode<{}, MoveResource<PatchedJWKsResponse>>({\n      aptosConfig,\n      originMethod: \"getKeylessJWKs\",\n      path: `accounts/${AccountAddress.from(jwkAddr).toString()}/resource/${resourceType}`,\n      params: { ledger_version: options?.ledgerVersion },\n    });\n    resource = data;\n  }\n\n  // Create a map of issuer to JWK arrays\n  const jwkMap = new Map<string, MoveJWK[]>();\n  for (const entry of resource.data.jwks.entries) {\n    const jwks: MoveJWK[] = [];\n    for (const jwkStruct of entry.jwks) {\n      const { data: jwkData } = jwkStruct.variant;\n      const deserializer = new Deserializer(Hex.fromHexInput(jwkData).toUint8Array());\n      const jwk = MoveJWK.deserialize(deserializer);\n      jwks.push(jwk);\n    }\n    jwkMap.set(hexToAsciiString(entry.issuer), jwks);\n  }\n\n  return jwkMap;\n}\n\nexport class MoveJWK extends Serializable {\n  public kid: string;\n\n  public kty: string;\n\n  public alg: string;\n\n  public e: string;\n\n  public n: string;\n\n  constructor(args: { kid: string; kty: string; alg: string; e: string; n: string }) {\n    super();\n    const { kid, kty, alg, e, n } = args;\n    this.kid = kid;\n    this.kty = kty;\n    this.alg = alg;\n    this.e = e;\n    this.n = n;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.kid);\n    serializer.serializeStr(this.kty);\n    serializer.serializeStr(this.alg);\n    serializer.serializeStr(this.e);\n    serializer.serializeStr(this.n);\n  }\n\n  static fromMoveStruct(struct: MoveAnyStruct): MoveJWK {\n    const { data } = struct.variant;\n    const deserializer = new Deserializer(Hex.fromHexInput(data).toUint8Array());\n    return MoveJWK.deserialize(deserializer);\n  }\n\n  static deserialize(deserializer: Deserializer): MoveJWK {\n    const kid = deserializer.deserializeStr();\n    const kty = deserializer.deserializeStr();\n    const alg = deserializer.deserializeStr();\n    const n = deserializer.deserializeStr();\n    const e = deserializer.deserializeStr();\n    return new MoveJWK({ kid, kty, alg, n, e });\n  }\n}\n\ninterface JwtHeader {\n  kid: string; // Key ID\n}\n/**\n * Safely parses the JWT header.\n * @param jwtHeader The JWT header string\n * @returns Parsed JWT header as an object.\n */\nexport function parseJwtHeader(jwtHeader: string): JwtHeader {\n  try {\n    const header = JSON.parse(jwtHeader);\n    if (header.kid === undefined) {\n      throw new Error(\"JWT header missing kid\");\n    }\n    return header;\n  } catch (error) {\n    throw new Error(\"Failed to parse JWT header.\");\n  }\n}\n"],"mappings":"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","names":["jwtDecode","sha3_256","EPK_HORIZON_SECS","MAX_AUD_VAL_BYTES","MAX_UID_KEY_BYTES","MAX_UID_VAL_BYTES","MAX_ISS_VAL_BYTES","MAX_EXTRA_FIELD_BYTES","MAX_JWT_HEADER_B64_BYTES","MAX_COMMITED_EPK_BYTES","_KeylessPublicKey","AccountPublicKey","iss","idCommitment","idcBytes","Hex","serializer","Serializer","AuthenticationKey","args","deserializer","addressSeed","publicKey","computeIdCommitment","jwt","pepper","uidKey","jwtPayload","jwtDecode","uidVal","KeylessPublicKey","aud","fields","bytesToBigIntLE","hashStrToField","bigIntToBytesLE","poseidonHash","KeylessSignature","_KeylessSignature","Signature","jwtHeader","ephemeralCertificate","expiryDateSecs","ephemeralPublicKey","ephemeralSignature","parseJwtHeader","EphemeralCertificate","EphemeralPublicKey","EphemeralSignature","ZeroKnowledgeSig","ZkProof","Groth16Zkp","Ed25519PublicKey","Ed25519Signature","signature","_EphemeralCertificate","variant","G1Bytes","_G1Bytes","Serializable","data","bytes","G2Bytes","_G2Bytes","_Groth16Zkp","Proof","a","b","c","_ZkProof","proof","_ZeroKnowledgeSig","expHorizonSecs","trainingWheelsSignature","extraField","overrideAudVal","Deserializer","KeylessConfiguration","_KeylessConfiguration","verificationKey","maxExpHorizonSecs","res","Groth16VerificationKey","_Groth16VerificationKey","alphaG1","betaG2","deltaG2","gammaAbcG1","gammaG2","sha3_256","getKeylessConfig","aptosConfig","memoizeAsync","config","getKeylessConfigurationResource","vk","getGroth16VerificationKeyResource","error","KeylessError","getIssAudAndUidVal","getErrorMessage","options","resourceType","getAptosFullNode","AccountAddress","getKeylessJWKs","jwkAddr","resource","jwkMap","entry","jwks","jwkStruct","jwkData","jwk","MoveJWK","hexToAsciiString","_MoveJWK","kid","kty","alg","e","struct","n","header"]}