{"version":3,"sources":["../../src/account/MultiKeyAccount.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Account } from \"./Account\";\nimport { MultiKey, MultiKeySignature, PublicKey } from \"../core/crypto\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { HexInput, SigningScheme } from \"../types\";\nimport { AccountAuthenticatorMultiKey } from \"../transactions/authenticator/account\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { AbstractKeylessAccount, KeylessSigner } from \"./AbstractKeylessAccount\";\nimport { AptosConfig } from \"../api/aptosConfig\";\n\n/**\n * Arguments required to verify a multi-key signature against a given message.\n *\n * @param message - The original message that was signed.\n * @param signature - The multi-key signature to be verified.\n */\nexport interface VerifyMultiKeySignatureArgs {\n  message: HexInput;\n  signature: MultiKeySignature;\n}\n\n/**\n * Signer implementation for the MultiKey authentication scheme.\n *\n * This account utilizes an M of N signing scheme, where M and N are specified in the {@link MultiKey}.\n * It signs messages using an array of M accounts, each corresponding to a public key in the {@link MultiKey}.\n *\n * Note: Generating a signer instance does not create the account on-chain.\n */\nexport class MultiKeyAccount implements Account, KeylessSigner {\n  /**\n   * Public key associated with the account\n   */\n  readonly publicKey: MultiKey;\n\n  /**\n   * Account address associated with the account\n   */\n  readonly accountAddress: AccountAddress;\n\n  /**\n   * Signing scheme used to sign transactions\n   */\n  readonly signingScheme: SigningScheme;\n\n  /**\n   * The signers used to sign messages.  These signers should correspond to public keys in the\n   * MultiKeyAccount's public key.  The number of signers should be equal or greater\n   * than this.publicKey.signaturesRequired\n   */\n  readonly signers: Account[];\n\n  /**\n   * An array of indices where for signer[i], signerIndicies[i] is the index of the corresponding public key in\n   * publicKey.publicKeys.  Used to derive the right public key to use for verification.\n   */\n  // TODO: Rename Indicies to Indices\n  readonly signerIndicies: number[];\n\n  readonly signaturesBitmap: Uint8Array;\n\n  /**\n   * Constructs a MultiKeyAccount instance, which requires multiple signatures for transactions.\n   *\n   * @param args - The arguments for creating a MultiKeyAccount.\n   * @param args.multiKey - The multikey of the account consisting of N public keys and a number M representing the required signatures.\n   * @param args.signers - An array of M signers that will be used to sign the transaction.\n   * @param args.address - An optional account address input. If not provided, the derived address from the public key will be used.\n   */\n  constructor(args: { multiKey: MultiKey; signers: Account[]; address?: AccountAddressInput }) {\n    const { multiKey, signers, address } = args;\n\n    this.publicKey = multiKey;\n    this.signingScheme = SigningScheme.MultiKey;\n\n    this.accountAddress = address ? AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();\n\n    // Get the index of each respective signer in the bitmap\n    const bitPositions: number[] = [];\n    for (const signer of signers) {\n      bitPositions.push(this.publicKey.getIndex(signer.publicKey));\n    }\n    // Zip signers and bit positions and sort signers by bit positions in order\n    // to ensure the signature is signed in ascending order according to the bitmap.\n    // Authentication on chain will fail otherwise.\n    const signersAndBitPosition: [Account, number][] = signers.map((signer, index) => [signer, bitPositions[index]]);\n    signersAndBitPosition.sort((a, b) => a[1] - b[1]);\n    this.signers = signersAndBitPosition.map((value) => value[0]);\n    this.signerIndicies = signersAndBitPosition.map((value) => value[1]);\n    this.signaturesBitmap = this.publicKey.createBitmap({ bits: bitPositions });\n  }\n\n  /**\n   * Static constructor to create a MultiKeyAccount using the provided public keys and signers.\n   *\n   * @param args - The arguments for creating a MultiKeyAccount.\n   * @param args.publicKeys - The N public keys of the MultiKeyAccount.\n   * @param args.signaturesRequired - The number of signatures required to authorize a transaction.\n   * @param args.signers - An array of M signers that will be used to sign the transaction.\n   * @returns MultiKeyAccount - The newly created MultiKeyAccount.\n   */\n  static fromPublicKeysAndSigners(args: {\n    publicKeys: PublicKey[];\n    signaturesRequired: number;\n    signers: Account[];\n  }): MultiKeyAccount {\n    const { publicKeys, signaturesRequired, signers } = args;\n    const multiKey = new MultiKey({ publicKeys, signaturesRequired });\n    return new MultiKeyAccount({ multiKey, signers });\n  }\n\n  /**\n   * Determines if the provided account is a multi-key account.\n   *\n   * @param account - The account to check.\n   * @returns A boolean indicating whether the account is a multi-key account.\n   */\n  static isMultiKeySigner(account: Account): account is MultiKeyAccount {\n    return account instanceof MultiKeyAccount;\n  }\n\n  /**\n   * Sign a message using the account's signers and return an AccountAuthenticator containing the signature along with the\n   * account's public key.\n   * @param message - The signing message, represented as binary input in hexadecimal format.\n   * @returns An instance of AccountAuthenticatorMultiKey that includes the signature and the public key.\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorMultiKey {\n    return new AccountAuthenticatorMultiKey(this.publicKey, this.sign(message));\n  }\n\n  /**\n   * Sign a transaction using the account's signers, returning an AccountAuthenticator that contains the signature and the\n   * account's public key.\n   * @param transaction - The raw transaction to be signed.\n   * @returns An AccountAuthenticatorMultiKey containing the signature of the transaction along with the account's public key.\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorMultiKey {\n    return new AccountAuthenticatorMultiKey(this.publicKey, this.signTransaction(transaction));\n  }\n\n  /**\n   * Waits for any proofs on KeylessAccount signers to be fetched. This ensures that signing with the KeylessAccount does not\n   * fail due to missing proofs.\n   * @return {Promise<void>} A promise that resolves when all proofs have been fetched.\n   */\n  async waitForProofFetch(): Promise<void> {\n    const keylessSigners = this.signers.filter(\n      (signer) => signer instanceof AbstractKeylessAccount,\n    ) as AbstractKeylessAccount[];\n    const promises = keylessSigners.map(async (signer) => signer.waitForProofFetch());\n    await Promise.all(promises);\n  }\n\n  /**\n   * Validates that the Keyless Account can be used to sign transactions.\n   * @return\n   */\n  async checkKeylessAccountValidity(aptosConfig: AptosConfig): Promise<void> {\n    const keylessSigners = this.signers.filter(\n      (signer) => signer instanceof AbstractKeylessAccount,\n    ) as AbstractKeylessAccount[];\n    const promises = keylessSigners.map((signer) => signer.checkKeylessAccountValidity(aptosConfig));\n    await Promise.all(promises);\n  }\n\n  /**\n   * Sign the given message using the MultiKeyAccount's signers\n   * @param message in HexInput format\n   * @returns MultiKeySignature\n   */\n  sign(data: HexInput): MultiKeySignature {\n    const signatures = [];\n    for (const signer of this.signers) {\n      signatures.push(signer.sign(data));\n    }\n    return new MultiKeySignature({ signatures, bitmap: this.signaturesBitmap });\n  }\n\n  /**\n   * Sign the given transaction using the MultiKeyAccount's signers.\n   * This function aggregates signatures from all signers associated with the MultiKeyAccount.\n   *\n   * @param transaction - The transaction to be signed.\n   * @returns MultiKeySignature - An object containing the aggregated signatures and a bitmap of the signatures.\n   */\n  signTransaction(transaction: AnyRawTransaction): MultiKeySignature {\n    const signatures = [];\n    for (const signer of this.signers) {\n      signatures.push(signer.signTransaction(transaction));\n    }\n    return new MultiKeySignature({ signatures, bitmap: this.signaturesBitmap });\n  }\n\n  /**\n   * Verify the given message and signature with the public keys.\n   *\n   * This function checks if the provided signatures are valid for the given message using the corresponding public keys.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The raw message data in HexInput format.\n   * @param args.signature - The signed message MultiKeySignature containing multiple signatures.\n   * @returns A boolean indicating whether the signatures are valid for the message.\n   */\n  verifySignature(args: VerifyMultiKeySignatureArgs): boolean {\n    const { message, signature } = args;\n    const isSignerIndicesSorted = this.signerIndicies.every(\n      (value, i) => i === 0 || value >= this.signerIndicies[i - 1],\n    );\n    if (!isSignerIndicesSorted) {\n      return false;\n    }\n    for (let i = 0; i < signature.signatures.length; i += 1) {\n      const singleSignature = signature.signatures[i];\n      const publicKey = this.publicKey.publicKeys[this.signerIndicies[i]];\n      if (!publicKey.verifySignature({ message, signature: singleSignature })) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"],"mappings":"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","names":["MultiKeyAccount","_MultiKeyAccount","args","multiKey","signers","address","AccountAddress","bitPositions","signer","signersAndBitPosition","index","a","b","value","publicKeys","signaturesRequired","MultiKey","account","message","AccountAuthenticatorMultiKey","transaction","promises","AbstractKeylessAccount","aptosConfig","data","signatures","MultiKeySignature","signature","i","singleSignature"]}