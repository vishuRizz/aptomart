{"version":3,"sources":["../../src/account/EphemeralKeyPair.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { randomBytes } from \"@noble/hashes/utils\";\n\nimport {\n  bytesToBigIntLE,\n  padAndPackBytesWithLen,\n  poseidonHash,\n  Ed25519PrivateKey,\n  EphemeralPublicKey,\n  EphemeralSignature,\n  PrivateKey,\n} from \"../core/crypto\";\nimport { Hex } from \"../core/hex\";\nimport { EphemeralPublicKeyVariant, HexInput } from \"../types\";\nimport { Deserializer, Serializable, Serializer } from \"../bcs\";\nimport { floorToWholeHour, nowInSeconds } from \"../utils/helpers\";\n\nconst TWO_WEEKS_IN_SECONDS = 1_209_600;\n\n/**\n * Represents an ephemeral key pair used for signing transactions via the Keyless authentication scheme.\n * This key pair is temporary and includes an expiration time.\n * For more details on how this class is used, refer to the documentation:\n * https://aptos.dev/guides/keyless-accounts/#1-present-the-user-with-a-sign-in-with-idp-button-on-the-ui\n */\nexport class EphemeralKeyPair extends Serializable {\n  static readonly BLINDER_LENGTH: number = 31;\n\n  /**\n   * A byte array of length BLINDER_LENGTH used to obfuscate the public key from the IdP.\n   * Used in calculating the nonce passed to the IdP and as a secret witness in proof generation.\n   */\n  readonly blinder: Uint8Array;\n\n  /**\n   * A timestamp in seconds indicating when the ephemeral key pair is expired.  After expiry, a new\n   * EphemeralKeyPair must be generated and a new JWT needs to be created.\n   */\n  readonly expiryDateSecs: number;\n\n  /**\n   * The value passed to the IdP when the user authenticates.  It consists of a hash of the\n   * ephemeral public key, expiry date, and blinder.\n   */\n  readonly nonce: string;\n\n  /**\n   * A private key used to sign transactions.  This private key is not tied to any account on the chain as it\n   * is ephemeral (not permanent) in nature.\n   */\n  private privateKey: PrivateKey;\n\n  /**\n   * A public key used to verify transactions.  This public key is not tied to any account on the chain as it\n   * is ephemeral (not permanent) in nature.\n   */\n  private publicKey: EphemeralPublicKey;\n\n  /**\n   * Creates an instance of the class with a specified private key, optional expiry date, and optional blinder.\n   * This constructor initializes the public key, sets the expiry date to a default value if not provided,\n   * generates a blinder if not supplied, and calculates the nonce based on the public key, expiry date, and blinder.\n   *\n   * @param args - The parameters for constructing the instance.\n   * @param args.privateKey - The private key used for creating the instance.\n   * @param args.expiryDateSecs - Optional expiry date in seconds from the current time. Defaults to two weeks from now.\n   * @param args.blinder - Optional blinder value. If not provided, a new blinder will be generated.\n   */\n  constructor(args: { privateKey: PrivateKey; expiryDateSecs?: number; blinder?: HexInput }) {\n    super();\n    const { privateKey, expiryDateSecs, blinder } = args;\n    this.privateKey = privateKey;\n    this.publicKey = new EphemeralPublicKey(privateKey.publicKey());\n    // By default, we set the expiry date to be two weeks in the future floored to the nearest hour\n    this.expiryDateSecs = expiryDateSecs || floorToWholeHour(nowInSeconds() + TWO_WEEKS_IN_SECONDS);\n    // Generate the blinder if not provided\n    this.blinder = blinder !== undefined ? Hex.fromHexInput(blinder).toUint8Array() : generateBlinder();\n    // Calculate the nonce\n    const fields = padAndPackBytesWithLen(this.publicKey.bcsToBytes(), 93);\n    fields.push(BigInt(this.expiryDateSecs));\n    fields.push(bytesToBigIntLE(this.blinder));\n    const nonceHash = poseidonHash(fields);\n    this.nonce = nonceHash.toString();\n  }\n\n  /**\n   * Returns the public key of the key pair.\n   * @return EphemeralPublicKey\n   */\n  getPublicKey(): EphemeralPublicKey {\n    return this.publicKey;\n  }\n\n  /**\n   * Checks if the current time has surpassed the expiry date of the key pair.\n   * @return boolean - Returns true if the key pair is expired, otherwise false.\n   */\n  isExpired(): boolean {\n    const currentTimeSecs: number = Math.floor(Date.now() / 1000);\n    return currentTimeSecs > this.expiryDateSecs;\n  }\n\n  /**\n   * Serializes the object's properties into a format suitable for transmission or storage.\n   * This function is essential for preparing the object data for serialization processes.\n   *\n   * @param serializer - The serializer instance used to serialize the object's properties.\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.publicKey.variant);\n    serializer.serializeBytes(this.privateKey.toUint8Array());\n    serializer.serializeU64(this.expiryDateSecs);\n    serializer.serializeFixedBytes(this.blinder);\n  }\n\n  /**\n   * Deserializes an ephemeral key pair from the provided deserializer.\n   * This function helps in reconstructing an ephemeral key pair, which is essential for cryptographic operations.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   */\n  static deserialize(deserializer: Deserializer): EphemeralKeyPair {\n    const variantIndex = deserializer.deserializeUleb128AsU32();\n    let privateKey: PrivateKey;\n    switch (variantIndex) {\n      case EphemeralPublicKeyVariant.Ed25519:\n        privateKey = Ed25519PrivateKey.deserialize(deserializer);\n        break;\n      default:\n        throw new Error(`Unknown variant index for EphemeralPublicKey: ${variantIndex}`);\n    }\n    const expiryDateSecs = deserializer.deserializeU64();\n    const blinder = deserializer.deserializeFixedBytes(31);\n    return new EphemeralKeyPair({ privateKey, expiryDateSecs: Number(expiryDateSecs), blinder });\n  }\n\n  /**\n   * Deserialize a byte array into an EphemeralKeyPair object.\n   * This function allows you to reconstruct an EphemeralKeyPair from its serialized byte representation.\n   *\n   * @param bytes - The byte array representing the serialized EphemeralKeyPair.\n   */\n  static fromBytes(bytes: Uint8Array): EphemeralKeyPair {\n    return EphemeralKeyPair.deserialize(new Deserializer(bytes));\n  }\n\n  /**\n   * Generates a new ephemeral key pair with an optional expiry date.\n   * This function allows you to create a temporary key pair for secure operations.\n   *\n   * @param args - Optional parameters for key pair generation.\n   * @param args.scheme - The type of key pair to use for the EphemeralKeyPair. Only Ed25519 is supported for now.\n   * @param args.expiryDateSecs - The date of expiry for the key pair in seconds.\n   * @returns An instance of EphemeralKeyPair containing the generated private key and expiry date.\n   */\n  static generate(args?: { scheme?: EphemeralPublicKeyVariant; expiryDateSecs?: number }): EphemeralKeyPair {\n    let privateKey: PrivateKey;\n\n    switch (args?.scheme) {\n      case EphemeralPublicKeyVariant.Ed25519:\n      default:\n        privateKey = Ed25519PrivateKey.generate();\n    }\n\n    return new EphemeralKeyPair({ privateKey, expiryDateSecs: args?.expiryDateSecs });\n  }\n\n  /**\n   * Sign the given data using the private key, returning an ephemeral signature.\n   * This function is essential for creating a secure signature that can be used for authentication or verification purposes.\n   *\n   * @param data - The data to be signed, provided in HexInput format.\n   * @returns EphemeralSignature - The resulting ephemeral signature.\n   * @throws Error - Throws an error if the EphemeralKeyPair has expired.\n   */\n  sign(data: HexInput): EphemeralSignature {\n    if (this.isExpired()) {\n      throw new Error(\"EphemeralKeyPair has expired\");\n    }\n    return new EphemeralSignature(this.privateKey.sign(data));\n  }\n}\n\n/**\n * Generates a random byte array of length EphemeralKeyPair.BLINDER_LENGTH.\n * @returns Uint8Array A random byte array used for blinding.\n */\nfunction generateBlinder(): Uint8Array {\n  return randomBytes(EphemeralKeyPair.BLINDER_LENGTH);\n}\n"],"mappings":"2TAGA,OAAS,eAAAA,MAAmB,sBAgB5B,IAAMC,EAAuB,QAQhBC,EAAN,MAAMA,UAAyBC,CAAa,CA2CjD,YAAYC,EAA+E,CACzF,MAAM,EACN,GAAM,CAAE,WAAAC,EAAY,eAAAC,EAAgB,QAAAC,CAAQ,EAAIH,EAChD,KAAK,WAAaC,EAClB,KAAK,UAAY,IAAIG,EAAmBH,EAAW,UAAU,CAAC,EAE9D,KAAK,eAAiBC,GAAkBG,EAAiBC,EAAa,EAAIT,CAAoB,EAE9F,KAAK,QAAUM,IAAY,OAAYI,EAAI,aAAaJ,CAAO,EAAE,aAAa,EAAIK,EAAgB,EAElG,IAAMC,EAASC,EAAuB,KAAK,UAAU,WAAW,EAAG,EAAE,EACrED,EAAO,KAAK,OAAO,KAAK,cAAc,CAAC,EACvCA,EAAO,KAAKE,EAAgB,KAAK,OAAO,CAAC,EACzC,IAAMC,EAAYC,EAAaJ,CAAM,EACrC,KAAK,MAAQG,EAAU,SAAS,CAClC,CAMA,cAAmC,CACjC,OAAO,KAAK,SACd,CAMA,WAAqB,CAEnB,OADgC,KAAK,MAAM,KAAK,IAAI,EAAI,GAAI,EACnC,KAAK,cAChC,CAQA,UAAUE,EAA8B,CACtCA,EAAW,sBAAsB,KAAK,UAAU,OAAO,EACvDA,EAAW,eAAe,KAAK,WAAW,aAAa,CAAC,EACxDA,EAAW,aAAa,KAAK,cAAc,EAC3CA,EAAW,oBAAoB,KAAK,OAAO,CAC7C,CAQA,OAAO,YAAYC,EAA8C,CAC/D,IAAMC,EAAeD,EAAa,wBAAwB,EACtDd,EACJ,OAAQe,EAAc,CACpB,OACEf,EAAagB,EAAkB,YAAYF,CAAY,EACvD,MACF,QACE,MAAM,IAAI,MAAM,iDAAiDC,CAAY,EAAE,CACnF,CACA,IAAMd,EAAiBa,EAAa,eAAe,EAC7CZ,EAAUY,EAAa,sBAAsB,EAAE,EACrD,OAAO,IAAIjB,EAAiB,CAAE,WAAAG,EAAY,eAAgB,OAAOC,CAAc,EAAG,QAAAC,CAAQ,CAAC,CAC7F,CAQA,OAAO,UAAUe,EAAqC,CACpD,OAAOpB,EAAiB,YAAY,IAAIqB,EAAaD,CAAK,CAAC,CAC7D,CAWA,OAAO,SAASlB,EAA0F,CACxG,IAAIC,EAEJ,OAAQD,GAAM,OAAQ,CACpB,OACA,QACEC,EAAagB,EAAkB,SAAS,CAC5C,CAEA,OAAO,IAAInB,EAAiB,CAAE,WAAAG,EAAY,eAAgBD,GAAM,cAAe,CAAC,CAClF,CAUA,KAAKoB,EAAoC,CACvC,GAAI,KAAK,UAAU,EACjB,MAAM,IAAI,MAAM,8BAA8B,EAEhD,OAAO,IAAIC,EAAmB,KAAK,WAAW,KAAKD,CAAI,CAAC,CAC1D,CACF,EA5JatB,EACK,eAAyB,GADpC,IAAMwB,EAANxB,EAkKP,SAASU,GAA8B,CACrC,OAAOe,EAAYD,EAAiB,cAAc,CACpD","names":["randomBytes","TWO_WEEKS_IN_SECONDS","_EphemeralKeyPair","Serializable","args","privateKey","expiryDateSecs","blinder","EphemeralPublicKey","floorToWholeHour","nowInSeconds","Hex","generateBlinder","fields","padAndPackBytesWithLen","bytesToBigIntLE","nonceHash","poseidonHash","serializer","deserializer","variantIndex","Ed25519PrivateKey","bytes","Deserializer","data","EphemeralSignature","EphemeralKeyPair","randomBytes"]}