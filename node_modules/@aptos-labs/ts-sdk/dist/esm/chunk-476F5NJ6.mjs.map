{"version":3,"sources":["../../src/internal/transactionSubmission.ts"],"sourcesContent":["/**\n * This file contains the underlying implementations for exposed submission API surface in\n * the {@link api/transaction}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * transaction namespace and without having a dependency cycle error.\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { Deserializer, MoveVector, U8 } from \"../bcs\";\nimport { postAptosFullNode } from \"../client\";\nimport { Account, AbstractKeylessAccount, isKeylessSigner } from \"../account\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { FederatedKeylessPublicKey, KeylessPublicKey, KeylessSignature, PrivateKey } from \"../core/crypto\";\nimport { AccountAuthenticator } from \"../transactions/authenticator/account\";\nimport { RotationProofChallenge } from \"../transactions/instances/rotationProofChallenge\";\nimport {\n  buildTransaction,\n  generateTransactionPayload,\n  generateSignedTransactionForSimulation,\n  generateSignedTransaction,\n} from \"../transactions/transactionBuilder/transactionBuilder\";\nimport {\n  InputGenerateTransactionData,\n  AnyRawTransaction,\n  InputSimulateTransactionData,\n  InputGenerateTransactionOptions,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n  InputSubmitTransactionData,\n  InputGenerateMultiAgentRawTransactionData,\n  InputGenerateSingleSignerRawTransactionData,\n  AnyTransactionPayloadInstance,\n  EntryFunctionABI,\n} from \"../transactions/types\";\nimport { getInfo } from \"./account\";\nimport { UserTransactionResponse, PendingTransactionResponse, MimeType, HexInput, TransactionResponse } from \"../types\";\nimport { SignedTransaction, TypeTagU8, TypeTagVector, generateSigningMessageForTransaction } from \"../transactions\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\nimport { MultiAgentTransaction } from \"../transactions/instances/multiAgentTransaction\";\n\n/**\n * We are defining function signatures, each with its specific input and output.\n * These are the possible function signature for `generateTransaction` function.\n * When we call `generateTransaction` function with the relevant type properties,\n * Typescript can infer the return type based on the appropriate function overload.\n */\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateSingleSignerRawTransactionData,\n): Promise<SimpleTransaction>;\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateMultiAgentRawTransactionData,\n): Promise<MultiAgentTransaction>;\n/**\n * Generates any transaction by passing in the required arguments\n *\n * @param args.sender The transaction sender's account address as a AccountAddressInput\n * @param args.data EntryFunctionData | ScriptData | MultiSigData\n * @param args.feePayerAddress optional. For a fee payer (aka sponsored) transaction\n * @param args.secondarySignerAddresses optional. For a multi-agent or fee payer (aka sponsored) transactions\n * @param args.options optional. GenerateTransactionOptions type\n *\n * @example\n * For a single signer entry function\n * move function name, move function type arguments, move function arguments\n * `\n * data: {\n *  function:\"0x1::aptos_account::transfer\",\n *  typeArguments:[]\n *  functionArguments :[receiverAddress,10]\n * }\n * `\n *\n * @example\n * For a single signer script function\n * module bytecode, move function type arguments, move function arguments\n * ```\n * data: {\n *  bytecode:\"0x001234567\",\n *  typeArguments:[],\n *  functionArguments :[receiverAddress,10]\n * }\n * ```\n *\n * @return An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses?: Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n */\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n): Promise<AnyRawTransaction> {\n  const payload = await buildTransactionPayload(args);\n  return buildRawTransaction(args, payload);\n}\n\n/**\n * Builds a transaction payload based on the provided configuration and input data.\n * This function is essential for preparing transaction data for execution on the Aptos blockchain.\n *\n * @param args - The arguments for building the transaction payload.\n * @param args.aptosConfig - Configuration settings for the Aptos network.\n * @param args.data - Input data required to generate the transaction payload, which may include bytecode, multisig address,\n * function name, function arguments, type arguments, and ABI.\n * @returns A promise that resolves to the generated transaction payload instance.\n */\nexport async function buildTransactionPayload(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n): Promise<AnyTransactionPayloadInstance> {\n  const { aptosConfig, data } = args;\n  // Merge in aptosConfig for remote ABI on non-script payloads\n  let generateTransactionPayloadData: InputGenerateTransactionPayloadDataWithRemoteABI;\n  let payload: AnyTransactionPayloadInstance;\n\n  if (\"bytecode\" in data) {\n    // TODO: Add ABI checking later\n    payload = await generateTransactionPayload(data);\n  } else if (\"multisigAddress\" in data) {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      multisigAddress: data.multisigAddress,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n      abi: data.abi,\n    };\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  } else {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n      abi: data.abi,\n    };\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  }\n  return payload;\n}\n\n/**\n * Builds a raw transaction based on the provided configuration and payload.\n * This function helps in creating a transaction that can be sent to the Aptos blockchain.\n *\n * @param args - The arguments for generating the transaction.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.sender - The address of the sender of the transaction.\n * @param args.options - Additional options for the transaction.\n * @param payload - The payload of the transaction, which defines the action to be performed.\n */\nexport async function buildRawTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n  payload: AnyTransactionPayloadInstance,\n): Promise<AnyRawTransaction> {\n  const { aptosConfig, sender, options } = args;\n\n  let feePayerAddress;\n  if (isFeePayerTransactionInput(args)) {\n    feePayerAddress = AccountAddress.ZERO.toString();\n  }\n\n  if (isMultiAgentTransactionInput(args)) {\n    const { secondarySignerAddresses } = args;\n    return buildTransaction({\n      aptosConfig,\n      sender,\n      payload,\n      options,\n      secondarySignerAddresses,\n      feePayerAddress,\n    });\n  }\n\n  return buildTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    feePayerAddress,\n  });\n}\n\n/**\n * Determine if the transaction input includes a fee payer.\n *\n * @param data - The input data for generating a transaction.\n * @param data.withFeePayer - Indicates whether a fee payer is included in the transaction input.\n * @returns A boolean value indicating if the transaction input has a fee payer.\n */\nfunction isFeePayerTransactionInput(data: InputGenerateTransactionData): boolean {\n  return data.withFeePayer === true;\n}\n\n/**\n * Determines whether the provided transaction input data includes multiple agent signatures.\n *\n * @param data - The transaction input data to evaluate.\n * @param data.secondarySignerAddresses - An array of secondary signer addresses, indicating multiple agents.\n */\nfunction isMultiAgentTransactionInput(\n  data: InputGenerateTransactionData,\n): data is InputGenerateMultiAgentRawTransactionData {\n  return \"secondarySignerAddresses\" in data;\n}\n\n/**\n * Builds a signing message that can be signed by external signers.\n *\n * Note: Please prefer using `signTransaction` unless signing outside the SDK.\n *\n * @param args - The arguments for generating the signing message.\n * @param args.transaction - AnyRawTransaction, as generated by `generateTransaction()`.\n *\n * @returns The message to be signed.\n */\nexport function getSigningMessage(args: { transaction: AnyRawTransaction }): Uint8Array {\n  const { transaction } = args;\n  return generateSigningMessageForTransaction(transaction);\n}\n\n/**\n * Sign a transaction that can later be submitted to the chain.\n *\n * @param args The arguments for signing the transaction.\n * @param args.signer The signer account to sign the transaction.\n * @param args.transaction An instance of a RawTransaction, plus optional secondary/fee payer addresses.\n *\n * @return The signer AccountAuthenticator.\n */\nexport function signTransaction(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n  const { signer, transaction } = args;\n  return signer.signTransactionWithAuthenticator(transaction);\n}\n\nexport function signAsFeePayer(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n  const { signer, transaction } = args;\n\n  // if transaction doesn't hold a \"feePayerAddress\" prop it means\n  // this is not a fee payer transaction\n  if (!transaction.feePayerAddress) {\n    throw new Error(`Transaction ${transaction} is not a Fee Payer transaction`);\n  }\n\n  // Set the feePayerAddress to the signer account address\n  transaction.feePayerAddress = signer.accountAddress;\n\n  return signTransaction({\n    signer,\n    transaction,\n  });\n}\n\n/**\n * Simulates a transaction before signing it to evaluate its potential outcome.\n *\n * @param args The arguments for simulating the transaction.\n * @param args.aptosConfig The configuration for the Aptos network.\n * @param args.transaction The raw transaction to simulate.\n * @param args.signerPublicKey Optional. The signer public key.\n * @param args.secondarySignersPublicKeys Optional. For when the transaction involves multiple signers.\n * @param args.feePayerPublicKey Optional. For when the transaction is sponsored by a fee payer.\n * @param args.options Optional. A configuration object to customize the simulation process.\n * @param args.options.estimateGasUnitPrice Optional. Indicates whether to estimate the gas unit price.\n * @param args.options.estimateMaxGasAmount Optional. Indicates whether to estimate the maximum gas amount.\n * @param args.options.estimatePrioritizedGasUnitPrice Optional. Indicates whether to estimate the prioritized gas unit price.\n */\nexport async function simulateTransaction(\n  args: { aptosConfig: AptosConfig } & InputSimulateTransactionData,\n): Promise<Array<UserTransactionResponse>> {\n  const { aptosConfig, transaction, signerPublicKey, secondarySignersPublicKeys, feePayerPublicKey, options } = args;\n\n  const signedTransaction = generateSignedTransactionForSimulation({\n    transaction,\n    signerPublicKey,\n    secondarySignersPublicKeys,\n    feePayerPublicKey,\n    options,\n  });\n\n  const { data } = await postAptosFullNode<Uint8Array, Array<UserTransactionResponse>>({\n    aptosConfig,\n    body: signedTransaction,\n    path: \"transactions/simulate\",\n    params: {\n      estimate_gas_unit_price: args.options?.estimateGasUnitPrice ?? false,\n      estimate_max_gas_amount: args.options?.estimateMaxGasAmount ?? false,\n      estimate_prioritized_gas_unit_price: args.options?.estimatePrioritizedGasUnitPrice ?? false,\n    },\n    originMethod: \"simulateTransaction\",\n    contentType: MimeType.BCS_SIGNED_TRANSACTION,\n  });\n  return data;\n}\n\n/**\n * Submit a transaction to the Aptos blockchain.\n *\n * @param args - The arguments for submitting the transaction.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.transaction - The Aptos transaction data to be submitted.\n * @param args.senderAuthenticator - The account authenticator of the transaction sender.\n * @param args.secondarySignerAuthenticators - Optional. Authenticators for additional signers in a multi-signer transaction.\n *\n * @returns PendingTransactionResponse - The response containing the status of the submitted transaction.\n */\nexport async function submitTransaction(\n  args: {\n    aptosConfig: AptosConfig;\n  } & InputSubmitTransactionData,\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig } = args;\n  const signedTransaction = generateSignedTransaction({ ...args });\n  try {\n    const { data } = await postAptosFullNode<Uint8Array, PendingTransactionResponse>({\n      aptosConfig,\n      body: signedTransaction,\n      path: \"transactions\",\n      originMethod: \"submitTransaction\",\n      contentType: MimeType.BCS_SIGNED_TRANSACTION,\n    });\n    return data;\n  } catch (e) {\n    const signedTxn = SignedTransaction.deserialize(new Deserializer(signedTransaction));\n    if (\n      signedTxn.authenticator.isSingleSender() &&\n      signedTxn.authenticator.sender.isSingleKey() &&\n      (signedTxn.authenticator.sender.public_key.publicKey instanceof KeylessPublicKey ||\n        signedTxn.authenticator.sender.public_key.publicKey instanceof FederatedKeylessPublicKey)\n    ) {\n      await AbstractKeylessAccount.fetchJWK({\n        aptosConfig,\n        publicKey: signedTxn.authenticator.sender.public_key.publicKey,\n        kid: (signedTxn.authenticator.sender.signature.signature as KeylessSignature).getJwkKid(),\n      });\n    }\n    throw e;\n  }\n}\n\nexport type FeePayerOrFeePayerAuthenticatorOrNeither =\n  | { feePayer: Account; feePayerAuthenticator?: never }\n  | { feePayer?: never; feePayerAuthenticator: AccountAuthenticator }\n  | { feePayer?: never; feePayerAuthenticator?: never };\n\nexport async function signAndSubmitTransaction(\n  args: FeePayerOrFeePayerAuthenticatorOrNeither & {\n    aptosConfig: AptosConfig;\n    signer: Account;\n    transaction: AnyRawTransaction;\n  },\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig, signer, feePayer, transaction } = args;\n  // If the signer contains a KeylessAccount, await proof fetching in case the proof\n  // was fetched asynchronously.\n  if (isKeylessSigner(signer)) {\n    await signer.checkKeylessAccountValidity(aptosConfig);\n  }\n  if (isKeylessSigner(feePayer)) {\n    await feePayer.checkKeylessAccountValidity(aptosConfig);\n  }\n  const feePayerAuthenticator =\n    args.feePayerAuthenticator || (feePayer && signAsFeePayer({ signer: feePayer, transaction }));\n\n  const senderAuthenticator = signTransaction({ signer, transaction });\n  return submitTransaction({\n    aptosConfig,\n    transaction,\n    senderAuthenticator,\n    feePayerAuthenticator,\n  });\n}\n\nexport async function signAndSubmitAsFeePayer(args: {\n  aptosConfig: AptosConfig;\n  feePayer: Account;\n  senderAuthenticator: AccountAuthenticator;\n  transaction: AnyRawTransaction;\n}): Promise<PendingTransactionResponse> {\n  const { aptosConfig, senderAuthenticator, feePayer, transaction } = args;\n\n  if (isKeylessSigner(feePayer)) {\n    await feePayer.checkKeylessAccountValidity(aptosConfig);\n  }\n\n  const feePayerAuthenticator = signAsFeePayer({ signer: feePayer, transaction });\n\n  return submitTransaction({\n    aptosConfig,\n    transaction,\n    senderAuthenticator,\n    feePayerAuthenticator,\n  });\n}\n\nconst packagePublishAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [TypeTagVector.u8(), new TypeTagVector(TypeTagVector.u8())],\n};\n\n/**\n * Publishes a package transaction to the Aptos blockchain.\n * This function allows you to create and send a transaction that publishes a package with the specified metadata and bytecode.\n *\n * @param args - The arguments for the package transaction.\n * @param args.aptosConfig - The configuration settings for the Aptos client.\n * @param args.account - The address of the account sending the transaction.\n * @param args.metadataBytes - The metadata associated with the package, represented as hexadecimal input.\n * @param args.moduleBytecode - An array of module bytecode, each represented as hexadecimal input.\n * @param args.options - Optional parameters for generating the transaction.\n */\nexport async function publicPackageTransaction(args: {\n  aptosConfig: AptosConfig;\n  account: AccountAddressInput;\n  metadataBytes: HexInput;\n  moduleBytecode: Array<HexInput>;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, account, metadataBytes, moduleBytecode, options } = args;\n\n  const totalByteCode = moduleBytecode.map((bytecode) => MoveVector.U8(bytecode));\n\n  return generateTransaction({\n    aptosConfig,\n    sender: AccountAddress.from(account),\n    data: {\n      function: \"0x1::code::publish_package_txn\",\n      functionArguments: [MoveVector.U8(metadataBytes), new MoveVector(totalByteCode)],\n      abi: packagePublishAbi,\n    },\n    options,\n  });\n}\n\nconst rotateAuthKeyAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [\n    new TypeTagU8(),\n    TypeTagVector.u8(),\n    new TypeTagU8(),\n    TypeTagVector.u8(),\n    TypeTagVector.u8(),\n    TypeTagVector.u8(),\n  ],\n};\n\n/**\n * Rotates the authentication key for a given account, allowing for enhanced security and management of account access.\n *\n * @param args - The arguments for rotating the authentication key.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.fromAccount - The account from which the authentication key will be rotated.\n * @param args.toNewPrivateKey - The new private key that will be associated with the account.\n *\n * @remarks\n * This function requires the current authentication key and the new private key to sign a challenge that validates the rotation.\n *\n * TODO: Need to refactor and move this function out of transactionSubmission.\n */\nexport async function rotateAuthKey(args: {\n  aptosConfig: AptosConfig;\n  fromAccount: Account;\n  toNewPrivateKey: PrivateKey;\n}): Promise<TransactionResponse> {\n  const { aptosConfig, fromAccount, toNewPrivateKey } = args;\n  const accountInfo = await getInfo({\n    aptosConfig,\n    accountAddress: fromAccount.accountAddress,\n  });\n\n  const newAccount = Account.fromPrivateKey({ privateKey: toNewPrivateKey, legacy: true });\n\n  const challenge = new RotationProofChallenge({\n    sequenceNumber: BigInt(accountInfo.sequence_number),\n    originator: fromAccount.accountAddress,\n    currentAuthKey: AccountAddress.from(accountInfo.authentication_key),\n    newPublicKey: newAccount.publicKey,\n  });\n\n  // Sign the challenge\n  const challengeHex = challenge.bcsToBytes();\n  const proofSignedByCurrentPrivateKey = fromAccount.sign(challengeHex);\n  const proofSignedByNewPrivateKey = newAccount.sign(challengeHex);\n\n  // Generate transaction\n  const rawTxn = await generateTransaction({\n    aptosConfig,\n    sender: fromAccount.accountAddress,\n    data: {\n      function: \"0x1::account::rotate_authentication_key\",\n      functionArguments: [\n        new U8(fromAccount.signingScheme), // from scheme\n        MoveVector.U8(fromAccount.publicKey.toUint8Array()),\n        new U8(newAccount.signingScheme), // to scheme\n        MoveVector.U8(newAccount.publicKey.toUint8Array()),\n        MoveVector.U8(proofSignedByCurrentPrivateKey.toUint8Array()),\n        MoveVector.U8(proofSignedByNewPrivateKey.toUint8Array()),\n      ],\n      abi: rotateAuthKeyAbi,\n    },\n  });\n  return signAndSubmitTransaction({\n    aptosConfig,\n    signer: fromAccount,\n    transaction: rawTxn,\n  });\n}\n"],"mappings":"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","names":["generateTransaction","args","payload","buildTransactionPayload","buildRawTransaction","aptosConfig","data","generateTransactionPayloadData","generateTransactionPayload","sender","options","feePayerAddress","isFeePayerTransactionInput","AccountAddress","isMultiAgentTransactionInput","secondarySignerAddresses","buildTransaction","getSigningMessage","transaction","generateSigningMessageForTransaction","signTransaction","signer","signAsFeePayer","simulateTransaction","signerPublicKey","secondarySignersPublicKeys","feePayerPublicKey","signedTransaction","generateSignedTransactionForSimulation","postAptosFullNode","submitTransaction","generateSignedTransaction","e","signedTxn","SignedTransaction","Deserializer","KeylessPublicKey","FederatedKeylessPublicKey","AbstractKeylessAccount","signAndSubmitTransaction","feePayer","isKeylessSigner","feePayerAuthenticator","senderAuthenticator","signAndSubmitAsFeePayer","packagePublishAbi","TypeTagVector","publicPackageTransaction","account","metadataBytes","moduleBytecode","totalByteCode","bytecode","MoveVector","rotateAuthKeyAbi","TypeTagU8","rotateAuthKey","fromAccount","toNewPrivateKey","accountInfo","getInfo","newAccount","Account","challengeHex","RotationProofChallenge","proofSignedByCurrentPrivateKey","proofSignedByNewPrivateKey","rawTxn","U8"]}