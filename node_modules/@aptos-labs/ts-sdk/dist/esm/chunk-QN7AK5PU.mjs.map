{"version":3,"sources":["../../src/transactions/transactionBuilder/transactionBuilder.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file handles the transaction creation lifecycle.\n * It holds different operations to generate a transaction payload, a raw transaction,\n * and a signed transaction that can be simulated, signed and submitted to chain.\n */\nimport { sha3_256 as sha3Hash } from \"@noble/hashes/sha3\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { AccountAddress, AccountAddressInput, Hex, PublicKey } from \"../../core\";\nimport {\n  AnyPublicKey,\n  AnySignature,\n  KeylessPublicKey,\n  KeylessSignature,\n  Secp256k1PublicKey,\n  FederatedKeylessPublicKey,\n  MultiKey,\n  MultiKeySignature,\n} from \"../../core/crypto\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"../../core/crypto/ed25519\";\nimport { getInfo } from \"../../internal/account\";\nimport { getLedgerInfo } from \"../../internal/general\";\nimport { getGasPriceEstimation } from \"../../internal/transaction\";\nimport { NetworkToChainId } from \"../../utils/apiEndpoints\";\nimport { DEFAULT_MAX_GAS_AMOUNT, DEFAULT_TXN_EXP_SEC_FROM_NOW } from \"../../utils/const\";\nimport { normalizeBundle } from \"../../utils/normalizeBundle\";\nimport {\n  AccountAuthenticator,\n  AccountAuthenticatorEd25519,\n  AccountAuthenticatorMultiKey,\n  AccountAuthenticatorNoAccountAuthenticator,\n  AccountAuthenticatorSingleKey,\n} from \"../authenticator/account\";\nimport {\n  TransactionAuthenticator,\n  TransactionAuthenticatorEd25519,\n  TransactionAuthenticatorFeePayer,\n  TransactionAuthenticatorMultiAgent,\n  TransactionAuthenticatorSingleSender,\n} from \"../authenticator/transaction\";\nimport {\n  ChainId,\n  EntryFunction,\n  FeePayerRawTransaction,\n  MultiAgentRawTransaction,\n  MultiSig,\n  MultiSigTransactionPayload,\n  RawTransaction,\n  Script,\n  TransactionPayloadEntryFunction,\n  TransactionPayloadMultiSig,\n  TransactionPayloadScript,\n} from \"../instances\";\nimport { SignedTransaction } from \"../instances/signedTransaction\";\nimport {\n  AnyRawTransaction,\n  AnyTransactionPayloadInstance,\n  EntryFunctionArgumentTypes,\n  InputGenerateMultiAgentRawTransactionArgs,\n  InputGenerateRawTransactionArgs,\n  InputGenerateSingleSignerRawTransactionArgs,\n  InputGenerateTransactionOptions,\n  InputScriptData,\n  InputSimulateTransactionData,\n  InputMultiSigDataWithRemoteABI,\n  InputEntryFunctionDataWithRemoteABI,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n  InputSubmitTransactionData,\n  InputGenerateTransactionPayloadDataWithABI,\n  InputEntryFunctionDataWithABI,\n  InputMultiSigDataWithABI,\n  InputViewFunctionDataWithRemoteABI,\n  InputViewFunctionDataWithABI,\n  FunctionABI,\n} from \"../types\";\nimport { convertArgument, fetchEntryFunctionAbi, fetchViewFunctionAbi, standardizeTypeTags } from \"./remoteAbi\";\nimport { memoizeAsync } from \"../../utils/memoize\";\nimport { getFunctionParts, isScriptDataInput } from \"./helpers\";\nimport { SimpleTransaction } from \"../instances/simpleTransaction\";\nimport { MultiAgentTransaction } from \"../instances/multiAgentTransaction\";\n\n/**\n * Builds a transaction payload based on the provided arguments and returns a transaction payload.\n * This function uses the RemoteABI by default, but can also utilize a specified ABI.\n * When we call our `generateTransactionPayload` function with the relevant type properties,\n * Typescript can infer the return type based on the appropriate function overload.\n * @param args - The input data for generating the transaction payload.\n * @param args.function - The function to be called, specified in the format \"moduleAddress::moduleName::functionName\".\n * @param args.functionArguments - The arguments to pass to the function.\n * @param args.typeArguments - The type arguments for the function.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.abi - The ABI to use for the transaction, if not using the RemoteABI.\n *\n * @returns TransactionPayload - The generated transaction payload, which can be of type TransactionPayloadScript,\n * TransactionPayloadMultiSig, or TransactionPayloadEntryFunction.\n */\nexport async function generateTransactionPayload(args: InputScriptData): Promise<TransactionPayloadScript>;\nexport async function generateTransactionPayload(\n  args: InputEntryFunctionDataWithRemoteABI,\n): Promise<TransactionPayloadEntryFunction>;\nexport async function generateTransactionPayload(\n  args: InputMultiSigDataWithRemoteABI,\n): Promise<TransactionPayloadMultiSig>;\n\n/**\n * Builds a transaction payload based on the data argument and returns\n * a transaction payload - TransactionPayloadScript | TransactionPayloadMultiSig | TransactionPayloadEntryFunction\n *\n * This uses the RemoteABI by default, and the remote ABI can be skipped by using generateTransactionPayloadWithABI\n *\n * @param args.data GenerateTransactionPayloadData\n *\n * @return TransactionPayload\n */\nexport async function generateTransactionPayload(\n  args: InputGenerateTransactionPayloadDataWithRemoteABI,\n): Promise<AnyTransactionPayloadInstance> {\n  if (isScriptDataInput(args)) {\n    return generateTransactionPayloadScript(args);\n  }\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  const functionAbi = await fetchAbi({\n    key: \"entry-function\",\n    moduleAddress,\n    moduleName,\n    functionName,\n    aptosConfig: args.aptosConfig,\n    abi: args.abi,\n    fetch: fetchEntryFunctionAbi,\n  });\n\n  // Fill in the ABI\n  return generateTransactionPayloadWithABI({ ...args, abi: functionAbi });\n}\n\n/**\n * Generates a transaction payload using the provided ABI and function details.\n * This function helps create a properly structured transaction payload for executing a specific function on a module.\n *\n * @param args - The input data required to generate the transaction payload.\n * @param args.abi - The ABI of the function to be executed.\n * @param args.function - The fully qualified name of the function in the format `moduleAddress::moduleName::functionName`.\n * @param args.typeArguments - An array of type arguments that correspond to the function's type parameters.\n * @param args.functionArguments - An array of arguments to be passed to the function.\n * @param args.multisigAddress - (Optional) The address for a multisig transaction if applicable.\n *\n * @throws Error if the type argument count does not match the ABI or if the number of function arguments is incorrect.\n */\nexport function generateTransactionPayloadWithABI(args: InputEntryFunctionDataWithABI): TransactionPayloadEntryFunction;\nexport function generateTransactionPayloadWithABI(args: InputMultiSigDataWithABI): TransactionPayloadMultiSig;\nexport function generateTransactionPayloadWithABI(\n  args: InputGenerateTransactionPayloadDataWithABI,\n): AnyTransactionPayloadInstance {\n  const functionAbi = args.abi;\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  // Ensure that all type arguments are typed properly\n  const typeArguments = standardizeTypeTags(args.typeArguments);\n\n  // Check the type argument count against the ABI\n  if (typeArguments.length !== functionAbi.typeParameters.length) {\n    throw new Error(\n      `Type argument count mismatch, expected ${functionAbi.typeParameters.length}, received ${typeArguments.length}`,\n    );\n  }\n\n  // Check all BCS types, and convert any non-BCS types\n  const functionArguments: Array<EntryFunctionArgumentTypes> = args.functionArguments.map((arg, i) =>\n    /**\n     * Converts the argument for a specified function using its ABI and type arguments.\n     * This function helps ensure that the correct number of arguments is provided for the function call.\n     *\n     * @param args - The arguments for the function call.\n     * @param args.function - The specific function to be invoked.\n     * @param functionAbi - The ABI (Application Binary Interface) of the function, which includes parameter details.\n     * @param arg - The argument to be converted.\n     * @param i - The index of the argument in the function call.\n     * @param typeArguments - Additional type arguments that may be required for the conversion.\n     */\n    // TODO: Fix JSDoc\n    convertArgument(args.function, functionAbi, arg, i, typeArguments),\n  );\n\n  // Check that all arguments are accounted for\n  if (functionArguments.length !== functionAbi.parameters.length) {\n    throw new Error(\n      // eslint-disable-next-line max-len\n      `Too few arguments for '${moduleAddress}::${moduleName}::${functionName}', expected ${functionAbi.parameters.length} but got ${functionArguments.length}`,\n    );\n  }\n\n  // Generate entry function payload\n  const entryFunctionPayload = EntryFunction.build(\n    `${moduleAddress}::${moduleName}`,\n    functionName,\n    typeArguments,\n    functionArguments,\n  );\n\n  // Send it as multi sig if it's a multisig payload\n  if (\"multisigAddress\" in args) {\n    const multisigAddress = AccountAddress.from(args.multisigAddress);\n    return new TransactionPayloadMultiSig(\n      new MultiSig(multisigAddress, new MultiSigTransactionPayload(entryFunctionPayload)),\n    );\n  }\n\n  // Otherwise send as an entry function\n  return new TransactionPayloadEntryFunction(entryFunctionPayload);\n}\n\n/**\n * Generates the payload for a view function call using the provided arguments.\n * This function helps in preparing the necessary data to interact with a specific view function on the blockchain.\n *\n * @param args - The input data required to generate the view function payload.\n * @param args.function - The function identifier in the format \"moduleAddress::moduleName::functionName\".\n * @param args.aptosConfig - Configuration settings for the Aptos client.\n * @param args.abi - The ABI (Application Binary Interface) of the module.\n *\n * @returns The generated payload for the view function call.\n */\nexport async function generateViewFunctionPayload(args: InputViewFunctionDataWithRemoteABI): Promise<EntryFunction> {\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  const functionAbi = await fetchAbi({\n    key: \"view-function\",\n    moduleAddress,\n    moduleName,\n    functionName,\n    aptosConfig: args.aptosConfig,\n    abi: args.abi,\n    fetch: fetchViewFunctionAbi,\n  });\n\n  // Fill in the ABI\n  return generateViewFunctionPayloadWithABI({ abi: functionAbi, ...args });\n}\n\n/**\n * Generates a payload for a view function call using the provided ABI and arguments.\n * This function ensures that the type arguments and function arguments are correctly formatted\n * and match the expected counts as defined in the ABI.\n *\n * @param args - The input data for generating the view function payload.\n * @param args.abi - The ABI of the function to be called.\n * @param args.function - The full name of the function in the format \"moduleAddress::moduleName::functionName\".\n * @param args.typeArguments - An array of type arguments to be used in the function call.\n * @param args.functionArguments - An array of arguments to be passed to the function.\n *\n * @throws Error if the type argument count does not match the ABI or if the function arguments\n * do not match the expected parameters defined in the ABI.\n */\nexport function generateViewFunctionPayloadWithABI(args: InputViewFunctionDataWithABI): EntryFunction {\n  const functionAbi = args.abi;\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  // Ensure that all type arguments are typed properly\n  const typeArguments = standardizeTypeTags(args.typeArguments);\n\n  // Check the type argument count against the ABI\n  if (typeArguments.length !== functionAbi.typeParameters.length) {\n    throw new Error(\n      `Type argument count mismatch, expected ${functionAbi.typeParameters.length}, received ${typeArguments.length}`,\n    );\n  }\n\n  // Check all BCS types, and convert any non-BCS types\n  const functionArguments: Array<EntryFunctionArgumentTypes> =\n    args?.functionArguments?.map((arg, i) => convertArgument(args.function, functionAbi, arg, i, typeArguments)) ?? [];\n\n  // Check that all arguments are accounted for\n  if (functionArguments.length !== functionAbi.parameters.length) {\n    throw new Error(\n      // eslint-disable-next-line max-len\n      `Too few arguments for '${moduleAddress}::${moduleName}::${functionName}', expected ${functionAbi.parameters.length} but got ${functionArguments.length}`,\n    );\n  }\n\n  // Generate entry function payload\n  return EntryFunction.build(`${moduleAddress}::${moduleName}`, functionName, typeArguments, functionArguments);\n}\n\n/**\n * Generates a transaction payload script based on the provided input data.\n * This function helps in creating a structured script for transaction processing.\n *\n * @param args - The input data required to generate the transaction payload script.\n * @param args.bytecode - The bytecode to be converted into a Uint8Array.\n * @param args.typeArguments - The type arguments that will be standardized.\n * @param args.functionArguments - The arguments for the function being called.\n * @returns A new instance of TransactionPayloadScript.\n */\nfunction generateTransactionPayloadScript(args: InputScriptData) {\n  return new TransactionPayloadScript(\n    new Script(\n      Hex.fromHexInput(args.bytecode).toUint8Array(),\n      standardizeTypeTags(args.typeArguments),\n      args.functionArguments,\n    ),\n  );\n}\n\n/**\n * Generates a raw transaction that can be sent to the Aptos network.\n *\n * @param args - The arguments for generating the raw transaction.\n * @param args.aptosConfig - The configuration for the Aptos network.\n * @param args.sender - The transaction's sender account address as a hex input.\n * @param args.payload - The transaction payload, which can be created using generateTransactionPayload().\n * @param args.options - Optional parameters for transaction generation.\n * @param args.feePayerAddress - The address of the fee payer for sponsored transactions.\n *\n * @returns RawTransaction - The generated raw transaction.\n */\nexport async function generateRawTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: AccountAddressInput;\n  payload: AnyTransactionPayloadInstance;\n  options?: InputGenerateTransactionOptions;\n  feePayerAddress?: AccountAddressInput;\n}): Promise<RawTransaction> {\n  const { aptosConfig, sender, payload, options, feePayerAddress } = args;\n\n  const getChainId = async () => {\n    if (NetworkToChainId[aptosConfig.network]) {\n      return { chainId: NetworkToChainId[aptosConfig.network] };\n    }\n    const info = await getLedgerInfo({ aptosConfig });\n    return { chainId: info.chain_id };\n  };\n\n  const getGasUnitPrice = async () => {\n    if (options?.gasUnitPrice) {\n      return { gasEstimate: options.gasUnitPrice };\n    }\n    const estimation = await getGasPriceEstimation({ aptosConfig });\n    return { gasEstimate: estimation.gas_estimate };\n  };\n\n  const getSequenceNumberForAny = async () => {\n    const getSequenceNumber = async () => {\n      if (options?.accountSequenceNumber !== undefined) {\n        return options.accountSequenceNumber;\n      }\n\n      return (await getInfo({ aptosConfig, accountAddress: sender })).sequence_number;\n    };\n\n    /**\n     * Check if is sponsored transaction to honor AIP-52\n     * {@link https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-52.md}\n     */\n    if (feePayerAddress && AccountAddress.from(feePayerAddress).equals(AccountAddress.ZERO)) {\n      // Handle sponsored transaction generation with the option that\n      // the main signer has not been created on chain\n      try {\n        // Check if main signer has been created on chain, if not assign sequence number 0\n        return await getSequenceNumber();\n      } catch (e: any) {\n        return 0;\n      }\n    } else {\n      return getSequenceNumber();\n    }\n  };\n  const [{ chainId }, { gasEstimate }, sequenceNumber] = await Promise.all([\n    getChainId(),\n    getGasUnitPrice(),\n    getSequenceNumberForAny(),\n  ]);\n\n  const { maxGasAmount, gasUnitPrice, expireTimestamp } = {\n    maxGasAmount: options?.maxGasAmount ? BigInt(options.maxGasAmount) : BigInt(DEFAULT_MAX_GAS_AMOUNT),\n    gasUnitPrice: options?.gasUnitPrice ?? BigInt(gasEstimate),\n    expireTimestamp: options?.expireTimestamp ?? BigInt(Math.floor(Date.now() / 1000) + DEFAULT_TXN_EXP_SEC_FROM_NOW),\n  };\n\n  return new RawTransaction(\n    AccountAddress.from(sender),\n    BigInt(sequenceNumber),\n    payload,\n    BigInt(maxGasAmount),\n    BigInt(gasUnitPrice),\n    BigInt(expireTimestamp),\n    new ChainId(chainId),\n  );\n}\n\n/**\n * Generates a transaction based on the provided arguments.\n * This function can create both simple and multi-agent transactions, allowing for flexible transaction handling.\n *\n * @param args - The input arguments for generating the transaction.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.sender - The transaction's sender account address as a hex input.\n * @param args.payload - The transaction payload, which can be created using `generateTransactionPayload()`.\n * @param args.options - Optional. Transaction options object.\n * @param args.secondarySignerAddresses - Optional. An array of addresses for additional signers in a multi-signature transaction.\n * @param args.feePayerAddress - Optional. The address of the fee payer for sponsored transactions.\n * @returns An instance of a transaction, which may include secondary signer addresses and a fee payer address.\n */\nexport async function buildTransaction(args: InputGenerateSingleSignerRawTransactionArgs): Promise<SimpleTransaction>;\nexport async function buildTransaction(args: InputGenerateMultiAgentRawTransactionArgs): Promise<MultiAgentTransaction>;\n\n/**\n * Generates a transaction based on the provided arguments\n *\n * Note: we can start with one function to support all different payload/transaction types,\n * and if to complex to use, we could have function for each type\n *\n * @param args.aptosConfig AptosConfig\n * @param args.sender The transaction's sender account address as a hex input\n * @param args.payload The transaction payload - can create by using generateTransactionPayload()\n * @param args.options optional. Transaction options object\n * @param args.secondarySignerAddresses optional. For when want to create a multi signers transaction\n * @param args.feePayerAddress optional. For when want to create a fee payer (aka sponsored) transaction\n *\n * @return An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses?: Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n */\nexport async function buildTransaction(args: InputGenerateRawTransactionArgs): Promise<AnyRawTransaction> {\n  const { aptosConfig, sender, payload, options, feePayerAddress } = args;\n  // generate raw transaction\n  const rawTxn = await generateRawTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    feePayerAddress,\n  });\n\n  // if multi agent transaction\n  if (\"secondarySignerAddresses\" in args) {\n    const signers: Array<AccountAddress> =\n      args.secondarySignerAddresses?.map((signer) => AccountAddress.from(signer)) ?? [];\n\n    return new MultiAgentTransaction(\n      rawTxn,\n      signers,\n      args.feePayerAddress ? AccountAddress.from(args.feePayerAddress) : undefined,\n    );\n  }\n  // return the raw transaction\n  return new SimpleTransaction(rawTxn, args.feePayerAddress ? AccountAddress.from(args.feePayerAddress) : undefined);\n}\n\n/**\n * Generate a signed transaction for simulation before submitting it to the chain.\n * This function helps in preparing a transaction that can be simulated, allowing users to verify its validity and expected behavior.\n *\n * @param args - The input data required to generate the signed transaction for simulation.\n * @param args.transaction - An Aptos transaction type to sign.\n * @param args.signerPublicKey - The public key of the signer.\n * @param args.secondarySignersPublicKeys - Optional. The public keys of secondary signers if it is a multi-signer transaction.\n * @param args.feePayerPublicKey - Optional. The public key of the fee payer in a sponsored transaction.\n * @param args.options - Optional. Additional options for simulating the transaction.\n *\n * @returns A signed serialized transaction that can be simulated.\n */\nexport function generateSignedTransactionForSimulation(args: InputSimulateTransactionData): Uint8Array {\n  const { signerPublicKey, transaction, secondarySignersPublicKeys, feePayerPublicKey } = args;\n\n  const accountAuthenticator = getAuthenticatorForSimulation(signerPublicKey);\n\n  // fee payer transaction\n  if (transaction.feePayerAddress) {\n    const transactionToSign = new FeePayerRawTransaction(\n      transaction.rawTransaction,\n      transaction.secondarySignerAddresses ?? [],\n      transaction.feePayerAddress,\n    );\n    let secondaryAccountAuthenticators: Array<AccountAuthenticator> = [];\n    if (transaction.secondarySignerAddresses) {\n      if (secondarySignersPublicKeys) {\n        secondaryAccountAuthenticators = secondarySignersPublicKeys.map((publicKey) =>\n          getAuthenticatorForSimulation(publicKey),\n        );\n      } else {\n        secondaryAccountAuthenticators = Array.from({ length: transaction.secondarySignerAddresses.length }, () =>\n          getAuthenticatorForSimulation(undefined),\n        );\n      }\n    }\n    const feePayerAuthenticator = getAuthenticatorForSimulation(feePayerPublicKey);\n\n    const transactionAuthenticator = new TransactionAuthenticatorFeePayer(\n      accountAuthenticator,\n      transaction.secondarySignerAddresses ?? [],\n      secondaryAccountAuthenticators,\n      {\n        address: transaction.feePayerAddress,\n        authenticator: feePayerAuthenticator,\n      },\n    );\n    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator).bcsToBytes();\n  }\n\n  // multi agent transaction\n  if (transaction.secondarySignerAddresses) {\n    const transactionToSign = new MultiAgentRawTransaction(\n      transaction.rawTransaction,\n      transaction.secondarySignerAddresses,\n    );\n\n    let secondaryAccountAuthenticators: Array<AccountAuthenticator> = [];\n\n    if (secondarySignersPublicKeys) {\n      secondaryAccountAuthenticators = secondarySignersPublicKeys.map((publicKey) =>\n        getAuthenticatorForSimulation(publicKey),\n      );\n    } else {\n      secondaryAccountAuthenticators = Array.from({ length: transaction.secondarySignerAddresses.length }, () =>\n        getAuthenticatorForSimulation(undefined),\n      );\n    }\n\n    const transactionAuthenticator = new TransactionAuthenticatorMultiAgent(\n      accountAuthenticator,\n      transaction.secondarySignerAddresses,\n      secondaryAccountAuthenticators,\n    );\n\n    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator).bcsToBytes();\n  }\n\n  // single signer raw transaction\n  let transactionAuthenticator;\n  if (accountAuthenticator instanceof AccountAuthenticatorEd25519) {\n    transactionAuthenticator = new TransactionAuthenticatorEd25519(\n      accountAuthenticator.public_key,\n      accountAuthenticator.signature,\n    );\n  } else if (\n    accountAuthenticator instanceof AccountAuthenticatorSingleKey ||\n    accountAuthenticator instanceof AccountAuthenticatorMultiKey\n  ) {\n    transactionAuthenticator = new TransactionAuthenticatorSingleSender(accountAuthenticator);\n  } else if (accountAuthenticator instanceof AccountAuthenticatorNoAccountAuthenticator) {\n    transactionAuthenticator = new TransactionAuthenticatorSingleSender(accountAuthenticator);\n  } else {\n    throw new Error(\"Invalid public key\");\n  }\n  return new SignedTransaction(transaction.rawTransaction, transactionAuthenticator).bcsToBytes();\n}\n\nexport function getAuthenticatorForSimulation(publicKey?: PublicKey) {\n  if (!publicKey) {\n    return new AccountAuthenticatorNoAccountAuthenticator();\n  }\n\n  // Wrap the public key types below with AnyPublicKey as they are only support through single sender.\n  // Learn more about AnyPublicKey here - https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-55.md\n  const convertToAnyPublicKey =\n    KeylessPublicKey.isInstance(publicKey) ||\n    FederatedKeylessPublicKey.isInstance(publicKey) ||\n    Secp256k1PublicKey.isInstance(publicKey);\n  const accountPublicKey = convertToAnyPublicKey ? new AnyPublicKey(publicKey) : publicKey;\n\n  // No need to for the signature to be matching in scheme. All that matters for simulations is that it's not valid\n  const invalidSignature = new Ed25519Signature(new Uint8Array(64));\n\n  if (Ed25519PublicKey.isInstance(accountPublicKey)) {\n    return new AccountAuthenticatorEd25519(accountPublicKey, invalidSignature);\n  }\n\n  if (AnyPublicKey.isInstance(accountPublicKey)) {\n    if (KeylessPublicKey.isInstance(accountPublicKey.publicKey)) {\n      return new AccountAuthenticatorSingleKey(\n        accountPublicKey,\n        new AnySignature(KeylessSignature.getSimulationSignature()),\n      );\n    }\n    return new AccountAuthenticatorSingleKey(accountPublicKey, new AnySignature(invalidSignature));\n  }\n\n  if (MultiKey.isInstance(accountPublicKey)) {\n    return new AccountAuthenticatorMultiKey(\n      accountPublicKey,\n      new MultiKeySignature({\n        signatures: accountPublicKey.publicKeys.map(() => new AnySignature(invalidSignature)),\n        bitmap: accountPublicKey.createBitmap({\n          bits: Array(accountPublicKey.publicKeys.length)\n            .fill(0)\n            .map((_, i) => i),\n        }),\n      }),\n    );\n  }\n\n  throw new Error(\"Unsupported PublicKey used for simulations\");\n}\n\n/**\n * Generate a signed transaction ready for submission to the blockchain.\n * This function prepares the transaction by authenticating the sender and any additional signers based on the provided arguments.\n *\n * @param args - The input data required to generate the signed transaction.\n * @param args.transaction - An Aptos transaction type containing the details of the transaction.\n * @param args.senderAuthenticator - The account authenticator of the transaction sender.\n * @param args.feePayerAuthenticator - The authenticator for the fee payer, required if the transaction has a fee payer address.\n * @param args.additionalSignersAuthenticators - Optional authenticators for additional signers in a multi-signer transaction.\n *\n * @returns A Uint8Array representing the signed transaction in bytes.\n *\n * @throws Error if the feePayerAuthenticator is not provided for a fee payer transaction.\n * @throws Error if additionalSignersAuthenticators are not provided for a multi-signer transaction.\n */\nexport function generateSignedTransaction(args: InputSubmitTransactionData): Uint8Array {\n  const { transaction, feePayerAuthenticator, additionalSignersAuthenticators } = args;\n  const senderAuthenticator = normalizeBundle(AccountAuthenticator, args.senderAuthenticator);\n\n  let txnAuthenticator: TransactionAuthenticator;\n  if (transaction.feePayerAddress) {\n    if (!feePayerAuthenticator) {\n      throw new Error(\"Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction\");\n    }\n    txnAuthenticator = new TransactionAuthenticatorFeePayer(\n      senderAuthenticator,\n      transaction.secondarySignerAddresses ?? [],\n      additionalSignersAuthenticators ?? [],\n      {\n        address: transaction.feePayerAddress,\n        authenticator: feePayerAuthenticator,\n      },\n    );\n  } else if (transaction.secondarySignerAddresses) {\n    if (!additionalSignersAuthenticators) {\n      throw new Error(\n        \"Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction\",\n      );\n    }\n    txnAuthenticator = new TransactionAuthenticatorMultiAgent(\n      senderAuthenticator,\n      transaction.secondarySignerAddresses,\n      additionalSignersAuthenticators,\n    );\n  } else if (senderAuthenticator instanceof AccountAuthenticatorEd25519) {\n    txnAuthenticator = new TransactionAuthenticatorEd25519(\n      senderAuthenticator.public_key,\n      senderAuthenticator.signature,\n    );\n  } else {\n    txnAuthenticator = new TransactionAuthenticatorSingleSender(senderAuthenticator);\n  }\n\n  return new SignedTransaction(transaction.rawTransaction, txnAuthenticator).bcsToBytes();\n}\n\n/**\n * Hashes the set of values using a SHA-3 256 hash algorithm.\n * @param input - An array of UTF-8 strings or Uint8Array byte arrays to be hashed.\n */\nexport function hashValues(input: (Uint8Array | string)[]): Uint8Array {\n  const hash = sha3Hash.create();\n  for (const item of input) {\n    hash.update(item);\n  }\n  return hash.digest();\n}\n\n/**\n * The domain separated prefix for hashing transactions\n */\nconst TRANSACTION_PREFIX = hashValues([\"APTOS::Transaction\"]);\n\n/**\n * Generates a user transaction hash for the provided transaction payload, which must already have an authenticator.\n * This function helps ensure the integrity and uniqueness of the transaction by producing a hash based on the signed transaction data.\n *\n * @param args - The input data required to submit the transaction.\n * @param args.authenticator - The authenticator for the transaction.\n * @param args.payload - The payload containing the transaction details.\n * @param args.sender - The address of the sender initiating the transaction.\n * @param args.sequenceNumber - The sequence number of the transaction for the sender.\n */\nexport function generateUserTransactionHash(args: InputSubmitTransactionData): string {\n  const signedTransaction = generateSignedTransaction(args);\n\n  // Transaction signature is defined as, the domain separated prefix based on struct (Transaction)\n  // Then followed by the type of the transaction for the enum, UserTransaction is 0\n  // Then followed by BCS encoded bytes of the signed transaction\n  return new Hex(hashValues([TRANSACTION_PREFIX, new Uint8Array([0]), signedTransaction])).toString();\n}\n\n/**\n * Fetches and caches ABIs while allowing for pass-through on provided ABIs.\n *\n * @param key - A unique identifier for the cached ABI.\n * @param moduleAddress - The address of the module from which to fetch the ABI.\n * @param moduleName - The name of the module containing the function.\n * @param functionName - The name of the function whose ABI is being fetched.\n * @param aptosConfig - Configuration settings for Aptos.\n * @param abi - An optional ABI to use if already available.\n * @param fetch - A function to fetch the ABI if it is not provided.\n */\nasync function fetchAbi<T extends FunctionABI>({\n  key,\n  moduleAddress,\n  moduleName,\n  functionName,\n  aptosConfig,\n  abi,\n  fetch,\n}: {\n  key: string;\n  moduleAddress: string;\n  moduleName: string;\n  functionName: string;\n  aptosConfig: AptosConfig;\n  abi?: T;\n  fetch: (moduleAddress: string, moduleName: string, functionName: string, aptosConfig: AptosConfig) => Promise<T>;\n}): Promise<T> {\n  if (abi !== undefined) {\n    return abi;\n  }\n\n  // We fetch the entry function ABI, and then pretend that we already had the ABI\n  return memoizeAsync(\n    async () => fetch(moduleAddress, moduleName, functionName, aptosConfig),\n    `${key}-${aptosConfig.network}-${moduleAddress}-${moduleName}-${functionName}`,\n    1000 * 60 * 5, // 5 minutes\n  )();\n}\n"],"mappings":"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","names":["sha3Hash","generateTransactionPayload","args","isScriptDataInput","generateTransactionPayloadScript","moduleAddress","moduleName","functionName","getFunctionParts","functionAbi","fetchAbi","fetchEntryFunctionAbi","generateTransactionPayloadWithABI","typeArguments","standardizeTypeTags","functionArguments","arg","i","convertArgument","entryFunctionPayload","EntryFunction","multisigAddress","AccountAddress","TransactionPayloadMultiSig","MultiSig","MultiSigTransactionPayload","TransactionPayloadEntryFunction","generateViewFunctionPayload","fetchViewFunctionAbi","generateViewFunctionPayloadWithABI","TransactionPayloadScript","Script","Hex","generateRawTransaction","aptosConfig","sender","payload","options","feePayerAddress","getChainId","NetworkToChainId","getLedgerInfo","getGasUnitPrice","getGasPriceEstimation","getSequenceNumberForAny","getSequenceNumber","getInfo","chainId","gasEstimate","sequenceNumber","maxGasAmount","gasUnitPrice","expireTimestamp","RawTransaction","ChainId","buildTransaction","rawTxn","signers","signer","MultiAgentTransaction","SimpleTransaction","generateSignedTransactionForSimulation","signerPublicKey","transaction","secondarySignersPublicKeys","feePayerPublicKey","accountAuthenticator","getAuthenticatorForSimulation","transactionToSign","FeePayerRawTransaction","secondaryAccountAuthenticators","publicKey","feePayerAuthenticator","transactionAuthenticator","TransactionAuthenticatorFeePayer","SignedTransaction","MultiAgentRawTransaction","TransactionAuthenticatorMultiAgent","AccountAuthenticatorEd25519","TransactionAuthenticatorEd25519","AccountAuthenticatorSingleKey","AccountAuthenticatorMultiKey","TransactionAuthenticatorSingleSender","AccountAuthenticatorNoAccountAuthenticator","accountPublicKey","KeylessPublicKey","FederatedKeylessPublicKey","Secp256k1PublicKey","AnyPublicKey","invalidSignature","Ed25519Signature","Ed25519PublicKey","AnySignature","KeylessSignature","MultiKey","MultiKeySignature","_","generateSignedTransaction","additionalSignersAuthenticators","senderAuthenticator","normalizeBundle","AccountAuthenticator","txnAuthenticator","hashValues","input","hash","sha3Hash","item","TRANSACTION_PREFIX","generateUserTransactionHash","signedTransaction","key","abi","fetch","memoizeAsync"]}