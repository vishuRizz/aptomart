{"version":3,"sources":["../../src/transactions/typeTag/index.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable class-methods-use-this */\n/* eslint-disable max-classes-per-file */\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { AccountAddress } from \"../../core\";\nimport { Identifier } from \"../instances/identifier\";\nimport { TypeTagVariants } from \"../../types\";\n\n/**\n * Represents a type tag in the serialization framework, serving as a base class for various specific type tags.\n * This class provides methods for serialization and deserialization of type tags, as well as type checking methods\n * to determine the specific type of the tag at runtime.\n *\n * @extends Serializable\n */\nexport abstract class TypeTag extends Serializable {\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Deserializes a StructTag from the provided deserializer.\n   * This function allows you to reconstruct a StructTag object from its serialized form.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   */\n  deserialize(deserializer: Deserializer): StructTag {\n    const address = AccountAddress.deserialize(deserializer);\n    const moduleName = Identifier.deserialize(deserializer);\n    const name = Identifier.deserialize(deserializer);\n    const typeArgs = deserializer.deserializeVector(TypeTag);\n    return new StructTag(address, moduleName, name, typeArgs);\n  }\n\n  static deserialize(deserializer: Deserializer): TypeTag {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TypeTagVariants.Bool:\n        return TypeTagBool.load(deserializer);\n      case TypeTagVariants.U8:\n        return TypeTagU8.load(deserializer);\n      case TypeTagVariants.U64:\n        return TypeTagU64.load(deserializer);\n      case TypeTagVariants.U128:\n        return TypeTagU128.load(deserializer);\n      case TypeTagVariants.Address:\n        return TypeTagAddress.load(deserializer);\n      case TypeTagVariants.Signer:\n        return TypeTagSigner.load(deserializer);\n      case TypeTagVariants.Vector:\n        return TypeTagVector.load(deserializer);\n      case TypeTagVariants.Struct:\n        return TypeTagStruct.load(deserializer);\n      case TypeTagVariants.U16:\n        return TypeTagU16.load(deserializer);\n      case TypeTagVariants.U32:\n        return TypeTagU32.load(deserializer);\n      case TypeTagVariants.U256:\n        return TypeTagU256.load(deserializer);\n      case TypeTagVariants.Generic:\n        // This is only used for ABI representation, and cannot actually be used as a type.\n        return TypeTagGeneric.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TypeTag: ${index}`);\n    }\n  }\n\n  abstract toString(): string;\n\n  /**\n   * Determines if the current instance is of type TypeTagBool.\n   *\n   * @returns {boolean} True if the instance is a TypeTagBool, otherwise false.\n   */\n  isBool(): this is TypeTagBool {\n    return this instanceof TypeTagBool;\n  }\n\n  /**\n   * Determines if the current instance is of type TypeTagAddress.\n   *\n   * @returns {boolean} True if the instance is a TypeTagAddress, otherwise false.\n   */\n  isAddress(): this is TypeTagAddress {\n    return this instanceof TypeTagAddress;\n  }\n\n  /**\n   * Determines if the current instance is of type TypeTagGeneric.\n   *\n   * @returns {boolean} Returns true if the instance is a TypeTagGeneric, otherwise false.\n   */\n  isGeneric(): this is TypeTagGeneric {\n    return this instanceof TypeTagGeneric;\n  }\n\n  /**\n   * Determine if the current instance is a TypeTagSigner.\n   *\n   * @returns {boolean} Returns true if the instance is a TypeTagSigner, otherwise false.\n   */\n  isSigner(): this is TypeTagSigner {\n    return this instanceof TypeTagSigner;\n  }\n\n  /**\n   * Checks if the current instance is a vector type.\n   * This can help determine the specific type of data structure being used.\n   *\n   * @returns {boolean} True if the instance is of type TypeTagVector, otherwise false.\n   */\n  isVector(): this is TypeTagVector {\n    return this instanceof TypeTagVector;\n  }\n\n  /**\n   * Determines if the current instance is a structure type.\n   *\n   * @returns {boolean} True if the instance is of type TypeTagStruct, otherwise false.\n   */\n  isStruct(): this is TypeTagStruct {\n    return this instanceof TypeTagStruct;\n  }\n\n  /**\n   * Determines if the current instance is of type `TypeTagU8`.\n   *\n   * @returns {boolean} Returns true if the instance is of type `TypeTagU8`, otherwise false.\n   */\n  isU8(): this is TypeTagU8 {\n    return this instanceof TypeTagU8;\n  }\n\n  /**\n   * Checks if the current instance is of type TypeTagU16.\n   *\n   * @returns {boolean} True if the instance is TypeTagU16, otherwise false.\n   */\n  isU16(): this is TypeTagU16 {\n    return this instanceof TypeTagU16;\n  }\n\n  /**\n   * Checks if the current instance is of type TypeTagU32.\n   *\n   * @returns {boolean} Returns true if the instance is TypeTagU32, otherwise false.\n   */\n  isU32(): this is TypeTagU32 {\n    return this instanceof TypeTagU32;\n  }\n\n  /**\n   * Checks if the current instance is of type TypeTagU64.\n   *\n   * @returns {boolean} True if the instance is a TypeTagU64, otherwise false.\n   */\n  isU64(): this is TypeTagU64 {\n    return this instanceof TypeTagU64;\n  }\n\n  /**\n   * Determines if the current instance is of the TypeTagU128 type.\n   *\n   * @returns {boolean} True if the instance is of TypeTagU128, otherwise false.\n   */\n  isU128(): this is TypeTagU128 {\n    return this instanceof TypeTagU128;\n  }\n\n  /**\n   * Checks if the current instance is of type TypeTagU256.\n   *\n   * @returns {boolean} Returns true if the instance is of type TypeTagU256, otherwise false.\n   */\n  isU256(): this is TypeTagU256 {\n    return this instanceof TypeTagU256;\n  }\n\n  isPrimitive(): boolean {\n    return (\n      this instanceof TypeTagSigner ||\n      this instanceof TypeTagAddress ||\n      this instanceof TypeTagBool ||\n      this instanceof TypeTagU8 ||\n      this instanceof TypeTagU16 ||\n      this instanceof TypeTagU32 ||\n      this instanceof TypeTagU64 ||\n      this instanceof TypeTagU128 ||\n      this instanceof TypeTagU256\n    );\n  }\n}\n\n/**\n * Represents a boolean type tag in the type system.\n * This class extends the base TypeTag class and provides\n * methods for serialization and deserialization of the boolean\n * type tag.\n *\n * @extends TypeTag\n */\nexport class TypeTagBool extends TypeTag {\n  /**\n   * Returns the string representation of the object.\n   *\n   * @returns {string} The string representation of the object.\n   */\n  toString(): string {\n    return \"bool\";\n  }\n\n  /**\n   * Serializes the current instance's properties into a provided serializer.\n   * This function ensures that the address, module name, name, and type arguments are properly serialized.\n   *\n   * @param serializer - The serializer instance used to serialize the properties.\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Bool);\n  }\n\n  /**\n   * Deserializes a StructTag and returns a new TypeTagStruct instance.\n   *\n   * @param _deserializer - The deserializer used to read the StructTag data.\n   */\n  static load(_deserializer: Deserializer): TypeTagBool {\n    return new TypeTagBool();\n  }\n}\n\n/**\n * Represents a type tag for an 8-bit unsigned integer (u8).\n * This class extends the base TypeTag class and provides methods\n * for serialization and deserialization specific to the u8 type.\n *\n * @extends TypeTag\n */\nexport class TypeTagU8 extends TypeTag {\n  toString(): string {\n    return \"u8\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U8);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU8 {\n    return new TypeTagU8();\n  }\n}\n\n/**\n * Represents a type tag for unsigned 16-bit integers (u16).\n * This class extends the base TypeTag class and provides methods for serialization and deserialization.\n *\n * @extends TypeTag\n */\nexport class TypeTagU16 extends TypeTag {\n  toString(): string {\n    return \"u16\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U16);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU16 {\n    return new TypeTagU16();\n  }\n}\n\n/**\n * Represents a type tag for a 32-bit unsigned integer (u32).\n * This class extends the base TypeTag class and provides methods for serialization\n * and deserialization specific to the u32 type.\n *\n * @extends TypeTag\n */\nexport class TypeTagU32 extends TypeTag {\n  toString(): string {\n    return \"u32\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U32);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU32 {\n    return new TypeTagU32();\n  }\n}\n\n/**\n * Represents a type tag for 64-bit unsigned integers (u64).\n * This class extends the base TypeTag class and provides methods for serialization and deserialization.\n *\n * @extends TypeTag\n */\nexport class TypeTagU64 extends TypeTag {\n  toString(): string {\n    return \"u64\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U64);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU64 {\n    return new TypeTagU64();\n  }\n}\n\n/**\n * Represents a type tag for the u128 data type.\n * This class extends the base TypeTag class and provides methods for serialization and deserialization.\n *\n * @extends TypeTag\n */\nexport class TypeTagU128 extends TypeTag {\n  toString(): string {\n    return \"u128\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U128);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU128 {\n    return new TypeTagU128();\n  }\n}\n\n/**\n * Represents a type tag for the U256 data type.\n * This class extends the base TypeTag class and provides methods for serialization and deserialization.\n *\n * @extends TypeTag\n */\nexport class TypeTagU256 extends TypeTag {\n  toString(): string {\n    return \"u256\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U256);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU256 {\n    return new TypeTagU256();\n  }\n}\n\n/**\n * Represents a type tag for an address in the system.\n * This class extends the TypeTag class and provides functionality\n * to serialize the address type and load it from a deserializer.\n *\n * @extends TypeTag\n */\nexport class TypeTagAddress extends TypeTag {\n  toString(): string {\n    return \"address\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Address);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagAddress {\n    return new TypeTagAddress();\n  }\n}\n\n/**\n * Represents a type tag for a signer in the system.\n * This class extends the base TypeTag and provides specific functionality\n * related to the signer type.\n *\n * @extends TypeTag\n */\nexport class TypeTagSigner extends TypeTag {\n  toString(): string {\n    return \"signer\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Signer);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagSigner {\n    return new TypeTagSigner();\n  }\n}\n\n/**\n * Represents a reference to a type tag in the type system.\n * This class extends the TypeTag class and provides functionality\n * to serialize and deserialize type tag references.\n *\n * @extends TypeTag\n */\nexport class TypeTagReference extends TypeTag {\n  toString(): `&${string}` {\n    return `&${this.value.toString()}`;\n  }\n\n  /**\n   * Initializes a new instance of the class with the specified parameters.\n   *\n   * @param value - The TypeTag to reference.\n   */\n  constructor(public readonly value: TypeTag) {\n    super();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Reference);\n  }\n\n  static load(deserializer: Deserializer): TypeTagReference {\n    const value = TypeTag.deserialize(deserializer);\n    return new TypeTagReference(value);\n  }\n}\n\n/**\n * Represents a generic type tag used for type parameters in entry functions.\n * Generics are not serialized into a real type, so they cannot be used as a type directly.\n *\n * @extends TypeTag\n */\nexport class TypeTagGeneric extends TypeTag {\n  toString(): `T${number}` {\n    return `T${this.value}`;\n  }\n\n  constructor(public readonly value: number) {\n    super();\n    if (value < 0) throw new Error(\"Generic type parameter index cannot be negative\");\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Generic);\n    serializer.serializeU32(this.value);\n  }\n\n  static load(deserializer: Deserializer): TypeTagGeneric {\n    const value = deserializer.deserializeU32();\n    return new TypeTagGeneric(value);\n  }\n}\n\n/**\n * Represents a vector type tag, which encapsulates a single type tag value.\n * This class extends the base TypeTag class and provides methods for serialization,\n * deserialization, and string representation of the vector type tag.\n *\n * @extends TypeTag\n */\nexport class TypeTagVector extends TypeTag {\n  toString(): `vector<${string}>` {\n    return `vector<${this.value.toString()}>`;\n  }\n\n  constructor(public readonly value: TypeTag) {\n    super();\n  }\n\n  /**\n   * Creates a new TypeTagVector instance with a TypeTagU8 type.\n   *\n   * @returns {TypeTagVector} A new TypeTagVector initialized with TypeTagU8.\n   */\n  static u8(): TypeTagVector {\n    return new TypeTagVector(new TypeTagU8());\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Vector);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TypeTagVector {\n    const value = TypeTag.deserialize(deserializer);\n    return new TypeTagVector(value);\n  }\n}\n\n/**\n * Represents a structured type tag in the system, extending the base TypeTag class.\n * This class encapsulates information about a specific structure, including its address,\n * module name, and type arguments, and provides methods for serialization and type checking.\n *\n * @param value - The StructTag instance containing the details of the structured type.\n */\nexport class TypeTagStruct extends TypeTag {\n  toString(): `0x${string}::${string}::${string}` {\n    // Collect type args and add it if there are any\n    let typePredicate = \"\";\n    if (this.value.typeArgs.length > 0) {\n      typePredicate = `<${this.value.typeArgs.map((typeArg) => typeArg.toString()).join(\", \")}>`;\n    }\n\n    return `${this.value.address.toString()}::${this.value.moduleName.identifier}::${\n      this.value.name.identifier\n    }${typePredicate}`;\n  }\n\n  constructor(public readonly value: StructTag) {\n    super();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Struct);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TypeTagStruct {\n    const value = StructTag.deserialize(deserializer);\n    return new TypeTagStruct(value);\n  }\n\n  /**\n   * Determines if the provided address, module name, and struct name match the current type tag.\n   *\n   * @param address - The account address to compare against the type tag.\n   * @param moduleName - The name of the module to compare against the type tag.\n   * @param structName - The name of the struct to compare against the type tag.\n   * @returns True if the address, module name, and struct name match the type tag; otherwise, false.\n   */\n  isTypeTag(address: AccountAddress, moduleName: string, structName: string): boolean {\n    return (\n      this.value.moduleName.identifier === moduleName &&\n      this.value.name.identifier === structName &&\n      this.value.address.equals(address)\n    );\n  }\n\n  /**\n   * Checks if the provided value is of type string.\n   * This function can help ensure that the data being processed is in the correct format before further operations.\n   *\n   * @returns {boolean} Returns true if the value is a string, otherwise false.\n   */\n  isString(): boolean {\n    return this.isTypeTag(AccountAddress.ONE, \"string\", \"String\");\n  }\n\n  /**\n   * Checks if the specified account address is of type \"option\".\n   *\n   * @returns {boolean} Returns true if the account address is an option type, otherwise false.\n   */\n  isOption(): boolean {\n    return this.isTypeTag(AccountAddress.ONE, \"option\", \"Option\");\n  }\n\n  /**\n   * Checks if the provided value is of type 'object'.\n   * This function helps determine if a value can be treated as an object type in the context of the SDK.\n   *\n   * @returns {boolean} Returns true if the value is an object, otherwise false.\n   */\n  isObject(): boolean {\n    return this.isTypeTag(AccountAddress.ONE, \"object\", \"Object\");\n  }\n}\n\n/**\n * Represents a structured tag that includes an address, module name,\n * name, and type arguments. This class is used to define and manage\n * structured data types within the SDK.\n *\n * @property {AccountAddress} address - The address associated with the struct tag.\n * @property {Identifier} moduleName - The name of the module that contains the struct.\n * @property {Identifier} name - The name of the struct.\n * @property {Array<TypeTag>} typeArgs - An array of type arguments associated with the struct.\n */\nexport class StructTag extends Serializable {\n  public readonly address: AccountAddress;\n\n  public readonly moduleName: Identifier;\n\n  public readonly name: Identifier;\n\n  public readonly typeArgs: Array<TypeTag>;\n\n  constructor(address: AccountAddress, module_name: Identifier, name: Identifier, type_args: Array<TypeTag>) {\n    super();\n    this.address = address;\n    this.moduleName = module_name;\n    this.name = name;\n    this.typeArgs = type_args;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serialize(this.address);\n    serializer.serialize(this.moduleName);\n    serializer.serialize(this.name);\n    serializer.serializeVector(this.typeArgs);\n  }\n\n  static deserialize(deserializer: Deserializer): StructTag {\n    const address = AccountAddress.deserialize(deserializer);\n    const moduleName = Identifier.deserialize(deserializer);\n    const name = Identifier.deserialize(deserializer);\n    const typeArgs = deserializer.deserializeVector(TypeTag);\n    return new StructTag(address, moduleName, name, typeArgs);\n  }\n}\n\n/**\n * Retrieves the StructTag for the AptosCoin, which represents the Aptos Coin in the Aptos blockchain.\n *\n * @returns {StructTag} The StructTag for the AptosCoin.\n */\nexport function aptosCoinStructTag(): StructTag {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"aptos_coin\"), new Identifier(\"AptosCoin\"), []);\n}\n\n/**\n * Returns a new StructTag representing a string type.\n *\n * @returns {StructTag} A StructTag for the string type.\n */\nexport function stringStructTag(): StructTag {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"string\"), new Identifier(\"String\"), []);\n}\n\n/**\n * Creates a new StructTag for the Option type with the specified type argument.\n * This can help in defining a specific instance of an Option type in your application.\n *\n * @param typeArg - The type tag that specifies the type of the value contained in the Option.\n */\nexport function optionStructTag(typeArg: TypeTag): StructTag {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"option\"), new Identifier(\"Option\"), [typeArg]);\n}\n\n/**\n * Creates a new StructTag for the Object type with the specified type argument.\n * This function helps in defining a structured representation of an Object with a specific type.\n *\n * @param typeArg - The type tag that specifies the type of the Object.\n */\nexport function objectStructTag(typeArg: TypeTag): StructTag {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"object\"), new Identifier(\"Object\"), [typeArg]);\n}\n"],"mappings":"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","names":["TypeTag","_TypeTag","Serializable","deserializer","address","AccountAddress","moduleName","Identifier","name","typeArgs","StructTag","index","TypeTagBool","TypeTagU8","TypeTagU64","TypeTagU128","TypeTagAddress","TypeTagSigner","TypeTagVector","TypeTagStruct","TypeTagU16","TypeTagU32","TypeTagU256","TypeTagGeneric","_TypeTagBool","serializer","_deserializer","_TypeTagU8","_TypeTagU16","_TypeTagU32","_TypeTagU64","_TypeTagU128","_TypeTagU256","_TypeTagAddress","_TypeTagSigner","TypeTagReference","_TypeTagReference","value","_TypeTagGeneric","_TypeTagVector","_TypeTagStruct","typePredicate","typeArg","structName","_StructTag","module_name","type_args","aptosCoinStructTag","stringStructTag","optionStructTag","objectStructTag"]}