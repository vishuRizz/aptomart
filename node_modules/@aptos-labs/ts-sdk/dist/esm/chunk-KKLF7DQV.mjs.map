{"version":3,"sources":["../../src/core/crypto/singleKey.ts"],"sourcesContent":["import { Deserializer, Serializer } from \"../../bcs\";\nimport { AnyPublicKeyVariant, AnySignatureVariant, SigningScheme as AuthenticationKeyScheme } from \"../../types\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"./ed25519\";\nimport { AccountPublicKey, PublicKey, VerifySignatureArgs } from \"./publicKey\";\nimport { Secp256k1PublicKey, Secp256k1Signature } from \"./secp256k1\";\nimport { KeylessPublicKey, KeylessSignature } from \"./keyless\";\nimport { Signature } from \"./signature\";\nimport { FederatedKeylessPublicKey } from \"./federatedKeyless\";\n\n/**\n * Represents any public key supported by Aptos.\n *\n * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports\n * `Legacy` and `Unified` authentication keys.\n *\n * Any unified authentication key is represented in the SDK as `AnyPublicKey`.\n */\nexport class AnyPublicKey extends AccountPublicKey {\n  /**\n   * Reference to the inner public key\n   */\n  public readonly publicKey: PublicKey;\n\n  /**\n   * Index of the underlying enum variant\n   */\n  public readonly variant: AnyPublicKeyVariant;\n\n  // region Constructors\n\n  /**\n   * Creates an instance of the signature class based on the provided signature type.\n   * This allows for the handling of different signature variants such as Ed25519, Secp256k1, and Keyless.\n   *\n   * @param publicKey - The publicKey object which determines the variant to be used.\n   * @throws Error if the provided signature type is unsupported.\n   */\n  constructor(publicKey: PublicKey) {\n    super();\n    this.publicKey = publicKey;\n    if (publicKey instanceof Ed25519PublicKey) {\n      this.variant = AnyPublicKeyVariant.Ed25519;\n    } else if (publicKey instanceof Secp256k1PublicKey) {\n      this.variant = AnyPublicKeyVariant.Secp256k1;\n    } else if (publicKey instanceof KeylessPublicKey) {\n      this.variant = AnyPublicKeyVariant.Keyless;\n    } else if (publicKey instanceof FederatedKeylessPublicKey) {\n      this.variant = AnyPublicKeyVariant.FederatedKeyless;\n    } else {\n      throw new Error(\"Unsupported public key type\");\n    }\n  }\n\n  // endregion\n\n  // region AccountPublicKey\n\n  /**\n   * Verifies the provided signature against the given message.\n   * This function helps ensure the integrity and authenticity of the message by confirming that the signature is valid.\n   *\n   * @param args - The arguments for signature verification.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify, which must be an instance of AnySignature.\n   * @returns A boolean indicating whether the signature is valid for the given message.\n   */\n  verifySignature(args: VerifySignatureArgs): boolean {\n    const { message, signature } = args;\n    if (!AnySignature.isInstance(signature)) {\n      return false;\n    }\n\n    return this.publicKey.verifySignature({\n      message,\n      signature: signature.signature,\n    });\n  }\n\n  /**\n   * Generates an authentication key from the current instance's byte representation.\n   * This function is essential for creating a unique identifier for authentication purposes.\n   *\n   * @returns {AuthenticationKey} The generated authentication key.\n   */\n  authKey(): AuthenticationKey {\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: AuthenticationKeyScheme.SingleKey,\n      input: this.toUint8Array(),\n    });\n  }\n\n  /**\n   * Get the signature in bytes (Uint8Array).\n   *\n   * This function is a warning that it will soon return the underlying signature bytes directly.\n   * Use AnySignature.bcsToBytes() instead.\n   *\n   * @returns Uint8Array representation of the signature.\n   */\n  toUint8Array() {\n    return this.bcsToBytes();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  /**\n   * Serializes the current object using the provided serializer.\n   * This function helps in converting the object into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.variant);\n    this.publicKey.serialize(serializer);\n  }\n\n  /**\n   * Deserializes an AnySignature from the provided deserializer.\n   * This function helps in reconstructing the AnySignature object from its serialized form, allowing for further processing or validation.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   */\n  static deserialize(deserializer: Deserializer): AnyPublicKey {\n    const variantIndex = deserializer.deserializeUleb128AsU32();\n    let publicKey: PublicKey;\n    switch (variantIndex) {\n      case AnyPublicKeyVariant.Ed25519:\n        publicKey = Ed25519PublicKey.deserialize(deserializer);\n        break;\n      case AnyPublicKeyVariant.Secp256k1:\n        publicKey = Secp256k1PublicKey.deserialize(deserializer);\n        break;\n      case AnyPublicKeyVariant.Keyless:\n        publicKey = KeylessPublicKey.deserialize(deserializer);\n        break;\n      case AnyPublicKeyVariant.FederatedKeyless:\n        publicKey = FederatedKeylessPublicKey.deserialize(deserializer);\n        break;\n      default:\n        throw new Error(`Unknown variant index for AnyPublicKey: ${variantIndex}`);\n    }\n    return new AnyPublicKey(publicKey);\n  }\n  // endregion\n\n  /**\n   * Determines if the provided public key is an instance of AnyPublicKey.\n   *\n   * @param publicKey - The public key to check.\n   * @deprecated Use `instanceof AnyPublicKey` instead.\n   */\n  static isPublicKey(publicKey: AccountPublicKey): publicKey is AnyPublicKey {\n    return publicKey instanceof AnyPublicKey;\n  }\n\n  /**\n   * Determines if the current public key is an instance of Ed25519PublicKey.\n   *\n   * @deprecated use `publicKey instanceof Ed25519PublicKey` instead.\n   */\n  isEd25519(): boolean {\n    return this.publicKey instanceof Ed25519PublicKey;\n  }\n\n  /**\n   * Checks if the public key is an instance of Secp256k1PublicKey.\n   *\n   * @deprecated use `publicKey instanceof Secp256k1PublicKey` instead.\n   */\n  isSecp256k1PublicKey(): boolean {\n    return this.publicKey instanceof Secp256k1PublicKey;\n  }\n\n  /**\n   * Determines if the provided publicKey is an instance of a valid PublicKey object.\n   *\n   * @param publicKey - The publicKey to be checked for validity.\n   * @param publicKey.publicKey - The actual publicKey object that needs to be validated.\n   * @returns True if the signature is a valid instance; otherwise, false.\n   */\n  static isInstance(publicKey: PublicKey): publicKey is AnyPublicKey {\n    return \"publicKey\" in publicKey && \"variant\" in publicKey;\n  }\n}\n\n/**\n * Represents a signature that utilizes the SingleKey authentication scheme.\n * This class is designed to encapsulate various types of signatures, which can\n * only be generated by a `SingleKeySigner` due to the shared authentication mechanism.\n *\n * @extends Signature\n */\nexport class AnySignature extends Signature {\n  public readonly signature: Signature;\n\n  /**\n   * Index of the underlying enum variant\n   */\n  private readonly variant: AnySignatureVariant;\n\n  // region Constructors\n\n  constructor(signature: Signature) {\n    super();\n    this.signature = signature;\n\n    if (signature instanceof Ed25519Signature) {\n      this.variant = AnySignatureVariant.Ed25519;\n    } else if (signature instanceof Secp256k1Signature) {\n      this.variant = AnySignatureVariant.Secp256k1;\n    } else if (signature instanceof KeylessSignature) {\n      this.variant = AnySignatureVariant.Keyless;\n    } else {\n      throw new Error(\"Unsupported signature type\");\n    }\n  }\n\n  // endregion\n\n  // region AccountSignature\n\n  toUint8Array() {\n    // TODO: keep this warning around for a bit, and eventually change this to return `this.signature.toUint8Array()`.\n    // eslint-disable-next-line no-console\n    console.warn(\n      \"[Aptos SDK] Calls to AnySignature.toUint8Array() will soon return the underlying signature bytes. \" +\n        \"Use AnySignature.bcsToBytes() instead.\",\n    );\n    return this.bcsToBytes();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.variant);\n    this.signature.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): AnySignature {\n    const variantIndex = deserializer.deserializeUleb128AsU32();\n    let signature: Signature;\n    switch (variantIndex) {\n      case AnySignatureVariant.Ed25519:\n        signature = Ed25519Signature.deserialize(deserializer);\n        break;\n      case AnySignatureVariant.Secp256k1:\n        signature = Secp256k1Signature.deserialize(deserializer);\n        break;\n      case AnySignatureVariant.Keyless:\n        signature = KeylessSignature.deserialize(deserializer);\n        break;\n      default:\n        throw new Error(`Unknown variant index for AnySignature: ${variantIndex}`);\n    }\n    return new AnySignature(signature);\n  }\n\n  // endregion\n\n  static isInstance(signature: Signature): signature is AnySignature {\n    return (\n      \"signature\" in signature &&\n      typeof signature.signature === \"object\" &&\n      signature.signature !== null &&\n      \"toUint8Array\" in signature.signature\n    );\n  }\n}\n"],"mappings":"0SAkBO,IAAMA,EAAN,MAAMC,UAAqBC,CAAiB,CAoBjD,YAAYC,EAAsB,CAGhC,GAFA,MAAM,EACN,KAAK,UAAYA,EACbA,aAAqBC,EACvB,KAAK,QAAU,UACND,aAAqBE,EAC9B,KAAK,QAAU,UACNF,aAAqBG,EAC9B,KAAK,QAAU,UACNH,aAAqBI,EAC9B,KAAK,QAAU,MAEf,OAAM,IAAI,MAAM,6BAA6B,CAEjD,CAeA,gBAAgBC,EAAoC,CAClD,GAAM,CAAE,QAAAC,EAAS,UAAAC,CAAU,EAAIF,EAC/B,OAAKG,EAAa,WAAWD,CAAS,EAI/B,KAAK,UAAU,gBAAgB,CACpC,QAAAD,EACA,UAAWC,EAAU,SACvB,CAAC,EANQ,EAOX,CAQA,SAA6B,CAC3B,OAAOE,EAAkB,mBAAmB,CAC1C,SACA,MAAO,KAAK,aAAa,CAC3B,CAAC,CACH,CAUA,cAAe,CACb,OAAO,KAAK,WAAW,CACzB,CAYA,UAAUC,EAA8B,CACtCA,EAAW,sBAAsB,KAAK,OAAO,EAC7C,KAAK,UAAU,UAAUA,CAAU,CACrC,CAQA,OAAO,YAAYC,EAA0C,CAC3D,IAAMC,EAAeD,EAAa,wBAAwB,EACtDX,EACJ,OAAQY,EAAc,CACpB,OACEZ,EAAYC,EAAiB,YAAYU,CAAY,EACrD,MACF,OACEX,EAAYE,EAAmB,YAAYS,CAAY,EACvD,MACF,OACEX,EAAYG,EAAiB,YAAYQ,CAAY,EACrD,MACF,OACEX,EAAYI,EAA0B,YAAYO,CAAY,EAC9D,MACF,QACE,MAAM,IAAI,MAAM,2CAA2CC,CAAY,EAAE,CAC7E,CACA,OAAO,IAAId,EAAaE,CAAS,CACnC,CASA,OAAO,YAAYA,EAAwD,CACzE,OAAOA,aAAqBF,CAC9B,CAOA,WAAqB,CACnB,OAAO,KAAK,qBAAqBG,CACnC,CAOA,sBAAgC,CAC9B,OAAO,KAAK,qBAAqBC,CACnC,CASA,OAAO,WAAWF,EAAiD,CACjE,MAAO,cAAeA,GAAa,YAAaA,CAClD,CACF,EASaQ,EAAN,MAAMK,UAAqBC,CAAU,CAU1C,YAAYP,EAAsB,CAIhC,GAHA,MAAM,EACN,KAAK,UAAYA,EAEbA,aAAqBQ,EACvB,KAAK,QAAU,UACNR,aAAqBS,EAC9B,KAAK,QAAU,UACNT,aAAqBU,EAC9B,KAAK,QAAU,MAEf,OAAM,IAAI,MAAM,4BAA4B,CAEhD,CAMA,cAAe,CAGb,eAAQ,KACN,0IAEF,EACO,KAAK,WAAW,CACzB,CAMA,UAAUP,EAA8B,CACtCA,EAAW,sBAAsB,KAAK,OAAO,EAC7C,KAAK,UAAU,UAAUA,CAAU,CACrC,CAEA,OAAO,YAAYC,EAA0C,CAC3D,IAAMC,EAAeD,EAAa,wBAAwB,EACtDJ,EACJ,OAAQK,EAAc,CACpB,OACEL,EAAYQ,EAAiB,YAAYJ,CAAY,EACrD,MACF,OACEJ,EAAYS,EAAmB,YAAYL,CAAY,EACvD,MACF,OACEJ,EAAYU,EAAiB,YAAYN,CAAY,EACrD,MACF,QACE,MAAM,IAAI,MAAM,2CAA2CC,CAAY,EAAE,CAC7E,CACA,OAAO,IAAIC,EAAaN,CAAS,CACnC,CAIA,OAAO,WAAWA,EAAiD,CACjE,MACE,cAAeA,GACf,OAAOA,EAAU,WAAc,UAC/BA,EAAU,YAAc,MACxB,iBAAkBA,EAAU,SAEhC,CACF","names":["AnyPublicKey","_AnyPublicKey","AccountPublicKey","publicKey","Ed25519PublicKey","Secp256k1PublicKey","KeylessPublicKey","FederatedKeylessPublicKey","args","message","signature","AnySignature","AuthenticationKey","serializer","deserializer","variantIndex","_AnySignature","Signature","Ed25519Signature","Secp256k1Signature","KeylessSignature"]}