{"version":3,"sources":["../../src/utils/helpers.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { decode } from \"js-base64\";\nimport { MoveStructId } from \"../types\";\n\n/**\n * Sleep for the specified amount of time in milliseconds.\n * This function can be used to introduce delays in asynchronous operations.\n *\n * @param timeMs - The time in milliseconds to sleep.\n */\nexport async function sleep(timeMs: number): Promise<null> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeMs);\n  });\n}\n\n/**\n * Get the error message from an unknown error.\n *\n * @param error The error to get the message from\n * @returns The error message\n */\nexport function getErrorMessage(error: unknown): string {\n  return error instanceof Error ? error.message : String(error);\n}\n\nexport const nowInSeconds = () => Math.floor(Date.now() / 1000);\n\n/**\n * Floors the given timestamp to the nearest whole hour.\n * This function is useful for normalizing timestamps to hourly intervals.\n *\n * @param timestampInSeconds - The timestamp in seconds to be floored.\n */\nexport function floorToWholeHour(timestampInSeconds: number): number {\n  const date = new Date(timestampInSeconds * 1000);\n  // Reset minutes and seconds to zero\n  date.setMinutes(0);\n  date.setSeconds(0);\n  date.setMilliseconds(0);\n  return Math.floor(date.getTime() / 1000);\n}\n\n/**\n * Decodes a base64 URL-encoded string into its original form.\n * This function is useful for converting base64 URL-encoded data back to a readable format.\n *\n * @param base64Url - The base64 URL-encoded string to decode.\n * @returns The decoded string.\n */\nexport function base64UrlDecode(base64Url: string): string {\n  // Replace base64url-specific characters\n  const base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Pad the string with '=' characters if needed\n  const paddedBase64 = base64 + \"==\".substring(0, (3 - (base64.length % 3)) % 3);\n  const decodedString = decode(paddedBase64);\n  return decodedString;\n}\n\n/**\n * Amount is represented in the smallest unit format on chain, this function converts\n * a human-readable amount format to the smallest unit format\n * @example\n * human-readable amount format: 500\n * on chain amount format when decimal is 8: 50000000000\n *\n * @param value The value in human-readable format\n * @param decimal The token decimal\n * @returns The value in the smallest units\n */\nexport const convertAmountFromHumanReadableToOnChain = (value: number, decimal: number) => value * 10 ** decimal;\n\n/**\n * Amount is represented in the smallest unit format on chain, this function converts\n * the smallest unit format to a human-readable amount format\n * @example\n * human-readable amount format: 500\n * on chain amount format when decimal is 8: 50000000000\n *\n * @param value The value in human-readable format\n * @param decimal The token decimal\n * @returns The value in the smallest units\n */\nexport const convertAmountFromOnChainToHumanReadable = (value: number, decimal: number) => value / 10 ** decimal;\n\n/**\n * Convert a hex string to an ascii string with the `0x` prefix.\n *\n * `0x6170746f735f636f696e` --> `aptos_coin`\n *\n * @param hex The hex string to convert (e.g. `0x6170746f735f636f696e`)\n * @returns The ascii string\n */\nconst hexToAscii = (hex: string) => {\n  let str = \"\";\n  for (let n = 2; n < hex.length; n += 2) {\n    str += String.fromCharCode(parseInt(hex.substring(n, n + 2), 16));\n  }\n  return str;\n};\n\n/**\n * Convert an encoded struct to a MoveStructId.\n *\n * @example\n * const structObj = {\n *   account_address: \"0x1\",\n *   module_name: \"0x6170746f735f636f696e\",\n *   struct_name: \"0x4170746f73436f696e\",\n * };\n * // structId is \"0x1::aptos_coin::AptosCoin\"\n * const structId = parseEncodedStruct(structObj);\n *\n * @param structObj The struct with account_address, module_name, and struct_name properties\n * @returns The MoveStructId\n */\nexport const parseEncodedStruct = (structObj: {\n  account_address: string;\n  module_name: string;\n  struct_name: string;\n}): MoveStructId => {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  const { account_address, module_name, struct_name } = structObj;\n  const moduleName = hexToAscii(module_name);\n  const structName = hexToAscii(struct_name);\n  return `${account_address}::${moduleName}::${structName}`;\n};\n\n/**\n * Determines whether the given object is an encoded struct type with the following properties:\n * - account_address: string\n * - module_name: string\n * - struct_name: string\n *\n * @param structObj The object to check\n * @returns Whether the object is an encoded struct type\n */\nexport const isEncodedStruct = (\n  structObj: any,\n): structObj is {\n  account_address: string;\n  module_name: string;\n  struct_name: string;\n} =>\n  typeof structObj === \"object\" &&\n  !Array.isArray(structObj) &&\n  structObj !== null &&\n  \"account_address\" in structObj &&\n  \"module_name\" in structObj &&\n  \"struct_name\" in structObj &&\n  typeof structObj.account_address === \"string\" &&\n  typeof structObj.module_name === \"string\" &&\n  typeof structObj.struct_name === \"string\";\n"],"mappings":"AAGA,OAAS,UAAAA,MAAc,YASvB,eAAsBC,EAAMC,EAA+B,CACzD,OAAO,IAAI,QAASC,GAAY,CAC9B,WAAWA,EAASD,CAAM,CAC5B,CAAC,CACH,CAQO,SAASE,EAAgBC,EAAwB,CACtD,OAAOA,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,CAC9D,CAEO,IAAMC,EAAe,IAAM,KAAK,MAAM,KAAK,IAAI,EAAI,GAAI,EAQvD,SAASC,EAAiBC,EAAoC,CACnE,IAAMC,EAAO,IAAI,KAAKD,EAAqB,GAAI,EAE/C,OAAAC,EAAK,WAAW,CAAC,EACjBA,EAAK,WAAW,CAAC,EACjBA,EAAK,gBAAgB,CAAC,EACf,KAAK,MAAMA,EAAK,QAAQ,EAAI,GAAI,CACzC,CASO,SAASC,EAAgBC,EAA2B,CAEzD,IAAMC,EAASD,EAAU,QAAQ,KAAM,GAAG,EAAE,QAAQ,KAAM,GAAG,EAEvDE,EAAeD,EAAS,KAAK,UAAU,GAAI,EAAKA,EAAO,OAAS,GAAM,CAAC,EAE7E,OADsBZ,EAAOa,CAAY,CAE3C,CAaO,IAAMC,EAA0C,CAACC,EAAeC,IAAoBD,EAAQ,IAAMC,EAa5FC,EAA0C,CAACF,EAAeC,IAAoBD,EAAQ,IAAMC,EAUnGE,EAAcC,GAAgB,CAClC,IAAIC,EAAM,GACV,QAASC,EAAI,EAAGA,EAAIF,EAAI,OAAQE,GAAK,EACnCD,GAAO,OAAO,aAAa,SAASD,EAAI,UAAUE,EAAGA,EAAI,CAAC,EAAG,EAAE,CAAC,EAElE,OAAOD,CACT,EAiBaE,EAAsBC,GAIf,CAElB,GAAM,CAAE,gBAAAC,EAAiB,YAAAC,EAAa,YAAAC,CAAY,EAAIH,EAChDI,EAAaT,EAAWO,CAAW,EACnCG,EAAaV,EAAWQ,CAAW,EACzC,MAAO,GAAGF,CAAe,KAAKG,CAAU,KAAKC,CAAU,EACzD,EAWaC,EACXN,GAMA,OAAOA,GAAc,UACrB,CAAC,MAAM,QAAQA,CAAS,GACxBA,IAAc,MACd,oBAAqBA,GACrB,gBAAiBA,GACjB,gBAAiBA,GACjB,OAAOA,EAAU,iBAAoB,UACrC,OAAOA,EAAU,aAAgB,UACjC,OAAOA,EAAU,aAAgB","names":["decode","sleep","timeMs","resolve","getErrorMessage","error","nowInSeconds","floorToWholeHour","timestampInSeconds","date","base64UrlDecode","base64Url","base64","paddedBase64","convertAmountFromHumanReadableToOnChain","value","decimal","convertAmountFromOnChainToHumanReadable","hexToAscii","hex","str","n","parseEncodedStruct","structObj","account_address","module_name","struct_name","moduleName","structName","isEncodedStruct"]}